{
    "centroid_tree": {
        "prefix": "centroid_tree",
        "body": "struct CentroidTree {\n    vector<int> subtree_size;\n    vector<int> centroid_parent;\n    vector<set<int>> adj;\n    void init(const vector<vector<int>> &_adj) {\n        int n = _adj.size();\n        centroid_parent.resize(n);\n        subtree_size.resize(n);\n        adj.resize(n);\n        for (int i = 0; i < n; i++)\n            for (int v : _adj[i])\n                adj[i].insert(v);\n    }\n    int dfs(int node, int parent = -1) {\n        subtree_size[node] = 1;\n        for (int neighbor : adj[node])\n            if (neighbor != parent)\n                subtree_size[node] += dfs(neighbor, node);\n        return subtree_size[node];\n    }\n    int centroid(int root) {\n        int n = dfs(root);\n        bool found;\n        // Repeatedly move to the subtree that is at least half of the tree, if such a subtree exists.\n        do {\n            found = false;\n            int root_size = subtree_size[root];\n            for (int neighbor : adj[root]) {\n                int cur_size = subtree_size[neighbor];\n                if (cur_size > root_size) continue;\n                if (2 * cur_size < n) continue;\n                root = neighbor, found = true;\n                break;\n            }\n        } while (found);\n        return root;\n    }\n    void decompose(int root, int cent_parent = -1) {\n        root = centroid(root);\n        centroid_parent[root] = cent_parent;\n        for (int neighbor : adj[root]) {\n            // Erase the edge from neighbor back to root.\n            adj[neighbor].erase(root);\n            decompose(neighbor, root);\n        }\n        adj[root].clear();\n    }\n};",
        "description": "centroid_tree",
        "scope": "cpp"
    },
    "closest_points_2d": {
        "prefix": "closest_points_2d",
        "body": "ll dist(pii u, pii v) {\n    u.fi -= v.fi, u.se -= v.se;\n    ll cur = 1LL * u.fi * u.fi + 1LL * u.se * u.se;\n    return cur;\n}\n// divide-and-conquer version\nll rec(int l, int r) {\n    ll mn = LLONG_MAX;\n    if (r - l <= 3) {\n        for (int i = l; i < r; ++i)\n            for (int j = i + 1; j < r; ++j)\n                mn = min(mn, dist(a[i], a[j]));\n        for (int i = l; i < r; ++i)\n            swap(a[i].fi, a[i].se);\n        sort(a.begin() + l, a.begin() + r);\n        return mn;\n    }\n    int m = (l + r) / 2, tsz = 0;\n    int midx = a[m].fi;\n    mn = min(rec(l, m), rec(m, r));\n    vector<pii> t(r - l);\n    auto it = a.begin();\n    merge(it + l, it + m, it + m, it + r, t.begin());\n    copy(t.begin(), t.end(), a.begin() + l);\n    int rt = sqrtl(mn) + 1;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].se - midx) >= rt) continue;\n        for (int j = tsz - 1; j >= 0 && a[i].fi - t[j].fi < rt; --j)\n            mn = min(mn, dist(a[i], t[j]));\n        t[tsz++] = a[i];\n    }\n    return mn;\n}\n// sweep-line version\nll ClosestPair(vector<pii> pts) {\n    int n = pts.size();\n    sort(pts.begin(), pts.end());\n    set<pii> s;\n    ll ans = LLONG_MAX;\n    int j = 0;\n    for (pii p : pts) {\n        int d = ceil(sqrtl(ans));\n        while (p.fi - pts[j].fi >= ans) {\n            s.erase({pts[j].se, pts[j].fi});\n            j++;\n        }\n        auto it1 = s.lower_bound({p.se - d, p.fi});\n        auto it2 = s.upper_bound({p.se + d, p.fi});\n        for (auto it = it1; it != it2; ++it)\n            ans = min(ans, dist(p, *it));      \n        s.insert({p.se, p.fi}); \n    }\n    return ans;\n}",
        "description": "closest_points_2d",
        "scope": "cpp"
    },
    "convex_hull_dp": {
        "prefix": "convex_hull_dp",
        "body": "// clang-format off\nstruct Line {\n    mutable ll k, m, p;\n    bool operator<(const Line& o) const { return k < o.k; }\n    bool operator<(ll x) const { return p < x; }\n};\nstruct ConvexHull : multiset<Line, less<>> {\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\n    const ll inf = LLONG_MAX;\n\tll div(ll a, ll b) { // floored division\n\t\treturn a / b - ((a ^ b) < 0 && a % b); }\n\tbool isect(iterator x, iterator y) {\n\t\tif (y == end()) { x->p = inf; return false; }\n\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;\n\t\telse x->p = div(y->m - x->m, x->k - y->k);\n\t\treturn x->p >= y->p;\n\t}\n    void add(ll k, ll m) {\n        auto z = insert({k, m, 0}), y = z++, x = y;\n        while (isect(y, z)) z = erase(z);\n        if (x != begin() && isect(--x, y)) isect(x, y = erase(y));\n        while ((y = x) != begin() && (--x)->p >= y->p)\n            isect(x, erase(y));\n    }\n    ll query(ll x) {\n        assert(!empty());\n        auto l = *lower_bound(x);\n        return l.k * x + l.m;\n    }\n};\n// clang-format on",
        "description": "convex_hull_trick",
        "scope": "cpp"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": "using ll = long long;\nconst ll inf = 1e18;\nvector<ll> dist, parent;\nvector<vector<pair<ll, ll>>> adj;\nvoid dijkstra(int s, int n) {\n\tusing pi = pair<ll, ll>;\n\tpriority_queue<pi> pq;\n\tdist.resize(n, inf);\n\tparent.resize(n, -1);\n\tpq.push(make_pair(0, s));\tdist[s] = 0;\n\twhile (!pq.empty()) {\n\t\tll v = pq.top().second;\n\t\tll d = -pq.top().first;\n\t\tpq.pop();\n\t\tif (d > dist[v]) continue;\n\t\tfor (pi p : adj[v]) {\n\t\t\tll u = p.first, w = p.second;\n\t\t\tif (dist[v] + w < dist[u]) {\n\t\t\t\tdist[u] = dist[v] + w;      // update the distance\n\t\t\t\tparent[u] = v;        // for extracting the shortest path\n\t\t\t\tpq.push(make_pair(-dist[u], u));\n\t\t\t}\n\t\t}\n\t}\n}",
        "description": "dijkstra",
        "scope": "cpp"
    },
    "includes_extended": {
        "prefix": "includes_extended",
        "body": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <ratio>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;",
        "description": "extended_includes_all",
        "scope": "cpp"
    },
    "fastio": {
        "prefix": "fastio",
        "body": "ios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);",
        "description": "fastio",
        "scope": "cpp"
    },
    "fft": {
        "prefix": "fft",
        "body": "using ll = long long;\nusing ld = double;\nstruct num {\n    ld x, y;\n    num(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}\n    num operator+(const num& b) { return num(x + b.x, y + b.y); }\n    num operator-(const num& b) { return num(x - b.x, y - b.y); }\n    num operator*(const num& b) { return num(x * b.x - y * b.y, x * b.y + y * b.x); }\n    num conj() { return num(x, -y); }\n    num pow(ll b = -1) {\n        if (x == 0 && y == 0) return num(0, 0);\n        if (b < 0) {\n            ld n = (x * x + y * y);\n            return num(x / n, -y / n).pow(-b);\n        }\n        num r = num(1, 0), a = *this;\n        do {\n            if (b & 1) r = r * a;\n            a = a * a;\n        } while (b >>= 1);\n        return r;\n    }\n};\nvector<int> rev({0, 1});\nvector<num> rt(2, num(1));\nstruct poly {\n    static void init(int n) {\n        int rts = rt.size();\n        if (n <= rts) return;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n            rev[i] = (rev[i >> 1] | ((i & 1) * n)) >> 1;\n        rt.reserve(n);\n        for (int k = rts; k < n; k *= 2) {\n            rt.resize(2 * k);\n            ld a = M_PI / k;\n            num z = num(cos(a), sin(a));\n            for (int i = k / 2; i < k; i++)\n                rt[2 * i] = rt[i], rt[2 * i + 1] = rt[i] * z;\n        }\n    }\n    static void fft(vector<num>& a, int n) {\n        init(n);\n        int s = rev.size();\n        s = __builtin_ctz(s / n);\n        for (int i = 0; i < n; i++)\n            if (i < (rev[i] >> s))\n                swap(a[i], a[rev[i] >> s]);\n        for (int k = 1; k < n; k *= 2) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    num t = rt[j + k] * a[i + j + k];\n                    a[i + j + k] = a[i + j] - t;\n                    a[i + j] = a[i + j] + t;\n                }\n            }\n        }\n    }\n    static vector<num> inverse(vector<num>& a) {\n        if (a.empty()) return {};\n        vector<num> b(1);\n        b[0] = a[0].pow();\n        b.reserve(2 * a.size());\n        vector<num> fa;\n        while (b.size() < a.size()) {\n            int n = 2 * b.size();\n            b.resize(2 * n, 0);\n            if (fa.size() < 2 * n) fa.resize(2 * n);\n            fill(fa.begin(), fa.begin() + 2 * n, 0);\n            copy(a.begin(), a.begin() + min(n, (int)a.size()), fa.begin());\n            fft(b, 2 * n), fft(fa, 2 * n);\n            num d = num(2 * n).pow();\n            for (int i = 0; i < 2 * n; i++)\n                b[i] = b[i] * (num(2) - fa[i] * b[i]) * d;\n            reverse(b.begin() + 1, b.end());\n            fft(b, 2 * n);\n            b.resize(n);\n        }\n        b.resize(a.size());\n        return b;\n    }\n    static vector<num> multiply(vector<num> a, vector<num> b) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return {};\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        a.resize(n), b.resize(n);\n        fft(a, n), fft(b, n);\n        num d = num(n).pow();\n        for (int i = 0; i < n; i++)\n            a[i] = a[i] * b[i] * d;\n        reverse(a.begin() + 1, a.end());\n        fft(a, n);\n        a.resize(s);\n        return a;\n    }\n    static vector<ld> multiply(const vector<ld>& a, const vector<ld>& b) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return vector<ld>();\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        vector<num> fa(n), fb(n);\n        fill(fa.begin(), fa.begin() + n, num(0, 0));\n        for (int i = 0; i < sza; i++)\n            fa[i].x = a[i];\n        for (int i = 0; i < szb; i++)\n            fa[i].y = b[i];\n        fft(fa, n);\n        for (num& x : fa) x = x * x;\n        for (int i = 0; i < n; i++)\n            fb[i] = fa[(n - i) & (n - 1)] - conj(fa[i]);\n        fft(fb, n);\n        vector<ld> r(s);\n        for (int i = 0; i < s; i++)\n            r[i] = fb[i].y / (4 * n);\n        return r;\n    }\n    // Integer multiply mod m (num = complex) /// start-hash\n    static vector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return vector<int>();\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        vector<num> fa(n), fb(n);\n        for (int i = 0; i < sza; i++)\n            fa[i] = num(a[i] & ((1 << 15) - 1), a[i] >> 15);\n        fill(fa.begin() + sza, fa.begin() + n, num(0, 0));\n        for (int i = 0; i < szb; i++)\n            fb[i] = num(b[i] & ((1 << 15) - 1), b[i] >> 15);\n        fill(fb.begin() + szb, fb.begin() + n, num(0, 0));\n        fft(fa, n), fft(fb, n);\n        ld r0 = 0.5 / n;\n        for (int i = 0; i <= n / 2; i++) {\n            int j = (n - i) & (n - 1);\n            num g0 = (fb[i] + conj(fb[j])) * r0;\n            num g1 = (fb[i] - conj(fb[j])) * r0;\n            swap(g1.x, g1.y);\n            g1.y *= -1;\n            if (j != i) {\n                swap(fa[j], fa[i]);\n                fb[j] = fa[j] * g1;\n                fa[j] = fa[j] * g0;\n            }\n            fb[i] = fa[i] * conj(g1);\n            fa[i] = fa[i] * conj(g0);\n        }\n        fft(fa, n), fft(fb, n);\n        vector<int> r(s, 0);\n        for (int i = 0; i < s; i++)\n            r[i] = int((ll(fa[i].x + 0.5) + (ll(fa[i].y + 0.5) % m << 15) + (ll(fb[i].x + 0.5) % m << 15) + (ll(fb[i].y + 0.5) % m << 30)) % m);\n        return r;\n    }\n    vector<num> coef;\n    poly(vector<num> v = {}) { coef = v; }\n    poly& operator+=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] + b.coef[i];\n        return *this;\n    }\n    poly operator+(const poly& b) {\n        poly r = *this;\n        r += b;\n        return r;\n    }\n    poly& operator-=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] - b.coef[i];\n        return *this;\n    }\n    poly operator-(const poly& b) {\n        poly r = *this;\n        r -= b;\n        return r;\n    }\n    poly operator*(const poly& b) {\n        return poly(multiply(coef, b.coef));\n    }\n    poly& operator*=(const poly& b) {\n        coef = multiply(coef, b.coef);\n        return *this;\n    }\n    poly& operator*=(const num& b) {\n        for (num& x : coef) x = x * b;\n        return *this;\n    }\n    // Polynomial floor division; no leading 0's plz\n    poly& operator/=(poly b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) {\n            coef.clear();\n            return *this;\n        }\n        int s = sza - szb + 1;\n        reverse(coef.begin(), coef.end());\n        reverse(b.coef.begin(), b.coef.end());\n        coef.resize(s), b.coef.resize(s);\n        coef = multiply(coef, inverse(b.coef));\n        coef.resize(s);\n        reverse(coef.begin(), coef.end());\n        return *this;\n    }\n    poly operator/(const poly& b) {\n        poly r = *this;\n        r /= b;\n        return r;\n    }\n    poly& operator%=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza >= szb) {\n            poly c = *this;\n            c /= b;\n            c *= b;\n            coef.resize(szb - 1);\n            for (int i = 0; i < sza; i++)\n                coef[i] = coef[i] - c.coef[i];\n        }\n        return *this;\n    }\n    poly operator%(const poly& b) {\n        poly r = *this;\n        r %= b;\n        return r;\n    }\n    poly deriv() {\n        if (coef.empty()) return poly();\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza - 1);\n        for (int i = 1; i < sza; i++)\n            b.coef[i - 1] = coef[i] * i;\n        return b;\n    }\n    poly integ() {\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza + 1);\n        b.coef[1] = 1;\n        for (int i = 1; i <= sza; i++)\n            b.coef[i] = coef[i - 1] * num(i).pow();\n        return b;\n    }\n    poly log() {  // coef[0] == 1\n        poly a = this->deriv();\n        poly b = poly(multiply(coef, inverse(a.coef)));\n        b = b.integ();\n        b.coef.resize(coef.size());\n        return b;\n    }\n    poly exp() {  // coef[0] == 0\n        poly b;\n        b.coef.assign(1, num(1));\n        if (coef.empty()) return b;\n        while (b.coef.size() < coef.size()) {\n            int sza = coef.size();\n            int szb = b.coef.size();\n            int n = min(szb * 2, sza);\n            b.coef.resize(n);\n            poly v;\n            v.coef.resize(n);\n            for (int i = 0; i < n; i++)\n                v.coef[i] = coef[i];\n            v -= b.log();\n            v.coef[0] = v.coef[0] + num(1);\n            b *= v;\n            b.coef.resize(n);\n        }\n        return b;\n    }\n    poly pow(int m) {  // m >= 0\n        poly b;\n        int sza = coef.size();\n        b.coef.resize(sza);\n        if (m == 0) {\n            b.coef[0] = 1;\n            return b;\n        }\n        int p = 0;\n        while (p < sza && coef[p].v == 0) ++p;\n        if (1LL * m * p >= sza) return b;\n        num mu = coef[p].pow(m), di = coef[p].pow();\n        poly c;\n        c.coef.resize(sza - m * p);\n        for (int i = 0; i < c.coef.size(); i++)\n            c.coef[i] = coef[i + p] * di;\n        c = c.log();\n        for (num& v : c.coef)\n            v = v * m;\n        c = c.exp();\n        for (int i = 0; i < c.coef.size(); i++)\n            b.coef[i + m * p] = c.coef[i] * mu;\n        return b;\n    }\n    vector<num> eval(const vector<num>& x) {\n        int n = x.size();\n        if (!n) return {};\n        vector<poly> up(2 * n);\n        for (int i = 0; i < n; i++) {\n            vector<num> tmp = {num(num(0) - x[i]), num(1)};\n            up[i + n] = poly(tmp);\n        }\n        for (int i = n - 1; i >= 1; i--)\n            up[i] = up[2 * i] * up[2 * i + 1];\n        vector<poly> down(2 * n);\n        down[1] = (*this) % up[1];\n        for (int i = 2; i < 2 * n; i++)\n            down[i] = down[i / 2] % up[i];\n        vector<num> y(n);\n        for (int i = 0; i < n; i++)\n            y[i] = down[i + n].coef[0];\n        return y;\n    }\n};\npoly interp(const vector<num>& x, const vector<num>& y) {\n    int n = x.size();\n    assert(n);\n    vector<poly> up(n * 2);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {num(num(0) - x[i]), num(1)};\n        up[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        up[i] = up[2 * i] * up[2 * i + 1];\n    vector<num> a = up[1].deriv().eval(x);\n    vector<poly> down(2 * n);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {a[i].pow() * y[i]};\n        down[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        down[i] = down[i * 2] * up[i * 2 + 1] + down[i * 2 + 1] * up[i * 2];\n    return down[1];\n}",
        "description": "fast_fourier_transform",
        "scope": "cpp"
    },
    "fenwick_tree_BIT": {
        "prefix": "fenwick_tree_BIT",
        "body": "vector<int> B1, B2;\nvoid add(vector<int>& B, int i, int x) {\n    int n = B.size();\n    for (; i < n; i += i & (-i))\n        B[i] = B[i] + x;\n}\nint sum(vector<int>& B, int i) {\n    int sum = 0;\n    for (; i > 0; i -= i & (-i))\n        sum = sum + B[i];\n    return sum;\n}\nint get(vector<int>& B, int i) {\n    if (i <= 0) return 0;\n    int val = B[i];\n    int z = i - (i & -i);\n    for (--i; i != z; i -= i & (-i))\n        val = val - B[i];\n    return val;\n}\nint bit_search(vector<int>& B, int val) {\n\tint sum = 0, pos = 0, s = B.size();\n\tfor (int i = log2(s); i >= 0; i--) {\n\t\tint d = (1 << i);\n\t\tif (pos + d < s && sum + B[pos + d] < val){\n\t\t\tpos = pos + d;\n\t\t\tsum = sum + B[pos];\n\t\t}\n\t}\n\treturn pos + 1;\n}\nvoid range_add(int l, int r, int x) {\n    if (r < l) return;\n    add(B1, l, x);\n    add(B1, r + 1, -x);\n    add(B2, l, x * (l - 1));\n    add(B2, r + 1, -x * r);\n}\nint range_sum(int l, int r) {\n    int res = 0;\n    if (r < l) return res;\n    res = res + sum(B1, r) * r;\n    res = res - sum(B2, r);\n    res = res + sum(B1, (l - 1)) * (l - 1);\n    res = res - sum(B2, (l - 1));\n    return res;\n}",
        "description": "fenwick_tree_binary_indexed",
        "scope": "cpp"
    },
    "freopen": {
        "prefix": "freopen",
        "body": "#ifdef LOCAL\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif",
        "description": "freopen",
        "scope": "cpp"
    },
    "grid_bfs": {
        "prefix": "grid_bfs",
        "body": "vector<string> g;\nconst int inf = 1e9;\nvector<int> dx = {-1, 0, 1, 0};\nvector<int> dy = {0, -1, 0, 1};\nvoid bfs(int sx, int sy) {\n    int n = g.size(), m = g[0].size();\n    vector<bool> vis(n * m, false);\n    vector<int> dist(n * m, inf);\n    int s = sx * m + sy;\n    queue<int> q;\n    q.push(s);\n    vis[s] = true;\n    dist[s] = 0;\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        int xx = v / m, yy = v % m;\n        for (int t = 0; t < 4; t++) {\n            int x = xx + dx[t];\n            int y = yy + dy[t];\n            if (x < 0 || x >= n) continue;\n            if (y < 0 || y >= m) continue;\n            int u = x * m + y;\n            if (vis[u] || g[x][y] == '#') continue;\n            q.push(u);\n            dist[u] = dist[v] + 1;\n            vis[u] = true;\n        }\n    }\n}",
        "description": "grid_bfs",
        "scope": "cpp"
    },
    "hashing": {
        "prefix": "hashing",
        "body": "typedef unsigned int uint;\ntemplate<typename T>\nuint vec_hash (const vector<T>& vec) {\n\tuint seed = vec.size();\n\tfor (T i : vec)\n\t\tseed ^= (uint)i + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n\treturn seed;\n}\nuint str_hash (const string s) {\n\tuint seed = s.size();\n\tfor (char i : vec)\n\t\tseed ^= (uint)i + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n\treturn seed;\n}",
        "description": "hash",
        "scope": "cpp"
    },
    "hld_template": {
        "prefix": "hld_template",
        "body": "int T = 0;\nvector<vector<int>> adj;\nvector<int> in, up, down, siz, par, depth;\nvoid init(int n) {\n    adj.resize(n);\n    in.resize(n);\n    siz.resize(n);\n    up.resize(n);\n    par.resize(n);\n    down.resize(n);\n    depth.resize(n);\n}\nvoid pre_dfs(int v = 0, int p = -1, int d = 0) {\n    depth[v] = d, siz[v] = 1, par[v] = p;\n    up[v] = down[v] = v;\n    for (int& u : adj[v]) {\n        if (u == p) continue;\n        pre_dfs(u, v, d + 1);\n        siz[v] += siz[u];\n        if (adj[v][0] == p || siz[u] > siz[adj[v][0]])\n            swap(u, adj[v][0]);\n    }\n}\nvoid dfs_hld(int v = 0, int p = -1) {\n    in[v] = T++;\n    for (int u : adj[v]) {\n        if (u == p) continue;\n        if (u == adj[v][0]) up[u] = up[v];\n        dfs_hld(u, v);\n        if (u == adj[v][0]) down[v] = down[u];\n    }\n}\nint path_query(int a, int b) {\n    int res = 0;\n    for (; up[a] != up[b]; b = par[up[b]]) {\n        if (depth[up[a]] > depth[up[b]]) swap(a, b);\n        // (in[up[b]], in[b]) is the segment \n    }\n    if (depth[a] > depth[b]) swap(a, b);\n    // (in[a], in[b]) is the segment\n    return res;\n}",
        "description": "heavy_light_decomposition",
        "scope": "cpp"
    },
    "kmp_prefix_function": {
        "prefix": "kmp_prefix_function",
        "body": "int kmp(string const& s) {\n    int n = s.size();\n    vector<int> lps(n, 0);\n    for (int i = 1; i < n; i++) {\n        int j = lps[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = lps[j - 1];\n        if (s[i] == s[j]) j++;\n        lps[i] = j;\n    }\n    return lps.back();\n}\nvoid kmp_aut(string s, vector<vector<int>>& aut) {\n    s += '#';\n    char base = 'a';\n    int n = s.size();\n    vector<int> pi = kmp(s);\n    aut.assign(n, vector<int>(26));\n    for (int i = 0; i < n; i++) {\n        for (int c = 0; c < 26; c++) {\n            if (i > 0 && base + c != s[i])\n                aut[i][c] = aut[pi[i - 1]][c];\n            else\n                aut[i][c] = i + (base + c == s[i]);\n        }\n    }\n}",
        "description": "kmp_prefix_function",
        "scope": "cpp"
    },
    "lca_extended": {
        "prefix": "lca_extended",
        "body": "struct LCA {\n    int n = 0;\n    vector<vector<int>> adj;\n    vector<int> parent, depth, subtree_size;\n    vector<int> euler, first_occurrence;\n    vector<int> tour_start, tour_end, tour_list, postorder;\n    vector<int> heavy_root;\n    RMQ<int> rmq;\n    bool built;\n    LCA(int _n = 0) {\n        init(_n);\n    }\n    // Warning: this does not call build().\n    LCA(const vector<vector<int>> &_adj) {\n        init(_adj);\n    }\n    void init(int _n) {\n        n = _n;\n        adj.assign(n, {});\n        parent.resize(n);\n        depth.resize(n);\n        subtree_size.resize(n);\n        first_occurrence.resize(n);\n        tour_start.resize(n);\n        tour_end.resize(n);\n        tour_list.resize(n);\n        postorder.resize(n);\n        heavy_root.resize(n);\n        built = false;\n    }\n    // Warning: this does not call build().\n    void init(const vector<vector<int>> &_adj) {\n        init(int(_adj.size()));\n        adj = _adj;\n    }\n    void add_edge(int a, int b) {\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    int degree(int v) const {\n        return int(adj[v].size()) + (built && parent[v] >= 0);\n    }\n    void dfs(int node, int par) {\n        parent[node] = par;\n        depth[node] = par < 0 ? 0 : depth[par] + 1;\n        subtree_size[node] = 1;\n        // Erase the edge to parent.\n        adj[node].erase(remove(adj[node].begin(), adj[node].end(), par), adj[node].end());\n        for (int child : adj[node]) {\n            dfs(child, node);\n            subtree_size[node] += subtree_size[child];\n        }\n        // Heavy-light subtree reordering.\n        sort(adj[node].begin(), adj[node].end(), [&](int a, int b) {\n            return subtree_size[a] > subtree_size[b];\n        });\n    }\n    int tour, post_tour;\n    void tour_dfs(int node, bool heavy) {\n        heavy_root[node] = heavy ? heavy_root[parent[node]] : node;\n        first_occurrence[node] = int(euler.size());\n        euler.push_back(node);\n        tour_list[tour] = node;\n        tour_start[node] = tour++;\n        bool heavy_child = true;\n        for (int child : adj[node]) {\n            tour_dfs(child, heavy_child);\n            euler.push_back(node);\n            heavy_child = false;\n        }\n        tour_end[node] = tour;\n        postorder[node] = post_tour++;\n    }\n    void build(int root = 0) {\n        parent.assign(n, -1);\n        dfs(root, -1);\n        for (int i = 0; i < n; i++)\n            if (i != root && parent[i] < 0)\n                dfs(i, -1);\n        tour = post_tour = 0;\n        euler.clear();\n        euler.reserve(2 * n);\n        for (int i = 0; i < n; i++)\n            if (parent[i] < 0) {\n                tour_dfs(i, false);\n                // Add a -1 in between connected components to help us detect when nodes aren't connected.\n                euler.push_back(-1);\n            }\n        assert(int(euler.size()) == 2 * n);\n        vector<int> euler_depths;\n        euler_depths.reserve(euler.size());\n        for (int node : euler)\n            euler_depths.push_back(node < 0 ? node : depth[node]);\n        rmq.build(euler_depths);\n        built = true;\n    }\n    pair<int, int> find_farthest(int node, int par, int path) const {\n        pair<int, int> current = {path, node};\n        for (int neighbor : adj[node])\n            if (neighbor != par)\n                current = max(current, find_farthest(neighbor, node, path + 1));\n \n        return current;\n    }\n    // Warning: this must be called before build(), since build() erases half of the edges.\n    pair<int, pair<int, int>> get_diameter() const {\n        int u = find_farthest(0, -1, 0).second;\n        pair<int, int> farthest = find_farthest(u, -1, 0);\n        int v = farthest.second;\n        return {farthest.first, {u, v}};\n    }\n    // Note: returns -1 if `a` and `b` aren't connected.\n    int get_lca(int a, int b) const {\n        a = first_occurrence[a];\n        b = first_occurrence[b];\n        if (a > b) swap(a, b);\n        return euler[rmq.query_index(a, b + 1)];\n    }\n    bool is_ancestor(int a, int b) const {\n        return tour_start[a] <= tour_start[b] && tour_start[b] < tour_end[a];\n    }\n    bool on_path(int x, int a, int b) const {\n        return (is_ancestor(x, a) || is_ancestor(x, b)) && is_ancestor(get_lca(a, b), x);\n    }\n    int get_dist(int a, int b) const {\n        return depth[a] + depth[b] - 2 * depth[get_lca(a, b)];\n    }\n    // Returns the child of `a` that is an ancestor of `b`. Assumes `a` is a strict ancestor of `b`.\n    int child_ancestor(int a, int b) const {\n        assert(a != b);\n        assert(is_ancestor(a, b));\n \n        // Note: this depends on RMQ breaking ties by latest index.\n        int child = euler[rmq.query_index(first_occurrence[a], first_occurrence[b] + 1) + 1];\n        assert(parent[child] == a);\n        assert(is_ancestor(child, b));\n        return child;\n    }\n    int get_kth_ancestor(int a, int k) const {\n        while (a >= 0) {\n            int root = heavy_root[a];\n            if (depth[root] <= depth[a] - k)\n                return tour_list[tour_start[a] - k];\n            k -= depth[a] - depth[root] + 1;\n            a = parent[root];\n        }\n        return a;\n    }\n    int get_kth_node_on_path(int a, int b, int k) const {\n        int anc = get_lca(a, b);\n        int first_half = depth[a] - depth[anc];\n        int second_half = depth[b] - depth[anc];\n        assert(0 <= k && k <= first_half + second_half);\n        if (k < first_half)\n            return get_kth_ancestor(a, k);\n        else\n            return get_kth_ancestor(b, first_half + second_half - k);\n    }\n    // Note: this is the LCA of any two nodes out of three when the third node is the root.\n    // It is also the node with the minimum sum of distances to all three nodes.\n    int get_common_node(int a, int b, int c) const {\n        // Return the deepest node among lca(a, b), lca(b, c), and lca(c, a).\n        int x = get_lca(a, b);\n        int y = get_lca(b, c);\n        int z = get_lca(c, a);\n        if (depth[y] > depth[x]) x = y;\n        if (depth[z] > depth[x]) x = z;\n        return x;\n    }\n \n    // Given a subset of k tree nodes, computes the minimal subtree that contains all the nodes (at most 2k - 1 nodes).\n    // Returns a list of {node, parent} for every node in the subtree. Runs in O(k log k).\n    vector<pair<int, int>> compress_tree(vector<int> nodes) const {\n        if (nodes.empty())\n            return {};\n        auto &&compare_tour = [&](int a, int b) { return tour_start[a] < tour_start[b]; };\n        sort(nodes.begin(), nodes.end(), compare_tour);\n        int k = int(nodes.size());\n        for (int i = 0; i < k - 1; i++)\n            nodes.push_back(get_lca(nodes[i], nodes[i + 1]));\n        sort(nodes.begin() + k, nodes.end(), compare_tour);\n        inplace_merge(nodes.begin(), nodes.begin() + k, nodes.end(), compare_tour);\n        nodes.erase(unique(nodes.begin(), nodes.end()), nodes.end());\n        vector<pair<int, int>> result = {{nodes[0], -1}};\n        for (int i = 1; i < int(nodes.size()); i++)\n            result.emplace_back(nodes[i], get_lca(nodes[i], nodes[i - 1]));\n        return result;\n    }\n};",
        "description": "lca_extended",
        "scope": "cpp"
    },
    "lca_simple": {
        "prefix": "lca_simple",
        "body": "struct LCA {\n    int n;\n    vector<vector<int>> adj;\n    vector<int> depth, euler, first_occurrence;\n    RMQ<int> rmq;\n    LCA() {}\n    void init(const vector<vector<int>> &_adj = {}) {\n        n = (int)_adj.size();\n        adj = _adj;\n        depth.resize(n);\n        first_occurrence.resize(n);\n    }\n    void dfs(int node, int parent) {\n        depth[node] = (parent == -1) ? 0 : depth[parent] + 1;\n        first_occurrence[node] = euler.size();\n        euler.push_back(node);\n        for (int neighbor : adj[node])\n            if (neighbor != parent) {\n                dfs(neighbor, node);\n                euler.push_back(node);\n            }\n    }\n    void build(int root = 0) {\n        dfs(root, -1);\n        assert((int)euler.size() == 2 * n - 1);\n        vector<int> euler_depths;\n        for (int node : euler)\n            euler_depths.push_back(depth[node]);\n        rmq.build(euler_depths);\n    }\n    int lca(int a, int b) const {\n        a = first_occurrence[a];\n        b = first_occurrence[b];\n        if (a > b) swap(a, b);\n        return euler[rmq.query_index(a, b + 1)];\n    }\n    int dist(int a, int b) const {\n        return depth[a] + depth[b] - 2 * depth[lca(a, b)];\n    }\n};",
        "description": "lca_simple",
        "scope": "cpp"
    },
    "levenshtein": {
        "prefix": "levenshtein",
        "body": "int editDist(string str1, string str2) {\n\tint m = str1.size(), n = str2.size();\n\tvector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\tfor (int i = 0; i <= m; i++)\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (i == 0) dp[i][j] = j;\n\t\t\telse if (j == 0) dp[i][j] = i;\n\t\t\telse if (str1[i - 1] == str2[j - 1])\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\telse\n\t\t\t\tdp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\n\t\t}\n\treturn dp[m][n];\n}",
        "description": "levenshtein",
        "scope": "cpp"
    },
    "link_cut_tree_splay": {
        "prefix": "link_cut_tree_splay",
        "body": "struct LinkCut {\n    struct node {\n        int p, ch[2], sz, id, maxid;\n        ll val, sub, lazy;\n        bool flip;\n        node(int i = 0, int v = 0) {\n            p = ch[0] = ch[1] = -1;\n            if (i != -1) id = maxid = i;\n            val = sub = v;\n            flip = lazy = 0;\n            sz = 1;\n        }\n    };\n    vector<node> t;\n    LinkCut(int n = 0) {\n        t.resize(n);\n        for (int i = 0; i < n; i++)\n            t[i] = node(i);\n    }\n    void push(int x) {\n        if (x == -1) return;\n        int &l = t[x].ch[0], &r = t[x].ch[1];\n        if (t[x].lazy) {\n            t[x].val += t[x].lazy, t[x].sub += t[x].lazy * t[x].sz;\n            if (l + 1) t[l].lazy += t[x].lazy;\n            if (r + 1) t[r].lazy += t[x].lazy;\n        }\n        if (t[x].flip) {\n            swap(l, r);\n            if (l + 1) t[l].flip ^= 1;\n            if (r + 1) t[r].flip ^= 1;\n        }\n        t[x].lazy = 0, t[x].flip = 0;\n    }\n    void pull(int x) {\n        if (x == -1) return;\n        t[x].sz = 1, t[x].sub = t[x].val, t[x].maxid = t[x].id;\n        for (int i = 0; i < 2; i++) {\n            int c = t[x].ch[i];\n            if (c == -1) continue;\n            push(c);\n            t[x].sz += t[c].sz;\n            t[x].maxid = max(t[x].maxid, t[c].maxid);\n            t[x].sub += t[c].sub;\n        }\n    }\n    bool is_root(int x) {\n        if (t[x].p == -1) return true;\n        int l = t[t[x].p].ch[0], r = t[t[x].p].ch[1];\n        return (l != x && r != x);\n    }\n    void rotate(int x) {\n        int p = t[x].p, pp = t[p].p;\n        if (!is_root(p)) t[pp].ch[t[pp].ch[1] == p] = x;\n        bool d = (t[p].ch[0] == x);\n        t[p].ch[!d] = t[x].ch[d], t[x].ch[d] = p;\n        if (t[p].ch[!d] + 1) t[t[p].ch[!d]].p = p;\n        t[x].p = pp, t[p].p = x;\n        pull(p), pull(x);\n    }\n    int splay(int x) {\n        while (!is_root(x)) {\n            int p = t[x].p, pp = t[p].p;\n            if (!is_root(p)) push(pp);\n            push(p), push(x);\n            if (!is_root(p))\n                rotate((t[pp].ch[0] == p) ^ (t[p].ch[0] == x) ? x : p);\n            rotate(x);\n        }\n        return push(x), x;\n    }\n    int access(int v) {\n        int last = -1;\n        for (int w = v; w + 1; pull(last = w), splay(v), w = t[v].p)\n            splay(w), t[w].ch[1] = (last == -1 ? -1 : v);\n        return last;\n    }\n    int find_root(int v) {\n        access(v), push(v);\n        while (t[v].ch[0] + 1) v = t[v].ch[0], push(v);\n        return splay(v);\n    }\n    bool connected(int v, int w) {\n        access(v), access(w);\n        return v == w ? true : t[v].p != -1;\n    }\n    void rootify(int v) {\n        access(v);\n        t[v].flip ^= 1;\n    }\n    int query(int v, int w) {\n        rootify(w), access(v);\n        return v;\n    }\n    void update(int v, int w, int x) {\n        rootify(w), access(v);\n        t[v].lazy += x;\n    }\n    void link(int v, int w) {\n        rootify(w);\n        t[w].p = v;\n    }\n    void cut(int v, int w) {\n        rootify(w), access(v);\n        t[v].ch[0] = t[t[v].ch[0]].p = -1;\n    }\n    int lca(int v, int w) {\n        access(v);\n        return access(w);\n    }\n};",
        "description": "link_cut_tree",
        "scope": "cpp"
    },
    "macros": {
        "prefix": "macros",
        "body": "typedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#define forn(i, a, b) for (int i = (a); i <= (b); i++)\n#define rfor(i, b, a) for (int i = (b); i >= (a); i--)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) (int)(v).size()\n#define rall(v) (v).rbegin(), (v).rend()\n#define runtime() (int)(1000 * ((double)clock()) / CLOCKS_PER_SEC)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define endl \"\\n\"",
        "description": "macros",
        "scope": "cpp"
    },
    "macros_extended": {
        "prefix": "macros_extended",
        "body": "#define forn(i, a, b) for (int i = (a); i <= (b); i++)\n#define rfor(i, b, a) for (int i = (b); i >= (a); i--)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forv(i, v) for (auto& (i) : (v))\n#define trav(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n\n#define all(v) (v).begin(), (v).end()\n#define sz(v) (int)(v).size()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pc(c) putchar(c)\n#define gc(c) getchar(c)\n#define runtime() (int)(1000 * ((double)clock()) / CLOCKS_PER_SEC)\n#define flush() cout << flush\n#define max_queue(t) priority_queue<t>\n#define min_queue(t) priority_queue<t,vector<t>,greater<t>>\n\n#define popcnt __builtin_popcount\n#define popcntll __builtin_popcountll\n#define ctz __builtin_ctz\n#define ctzll __builtin_ctzll\n\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define ef emplace_front\n#define eb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define rsz resize\n#define ins insert\n#define endl \"\\n\"",
        "description": "macros_extended",
        "scope": "cpp"
    },
    "matrix-arithmetic": {
        "prefix": "matrix-arithmetic",
        "body": "struct Matrix {\n    using vi = vector<int>;\n    int n, m, mod = 1e9 + 7;\n    vector<vi> M;\n    Matrix(int n1, int m1) {\n        n = n1, m = m1;\n        M.assign(n, vi(m, 0));\n    }\n    Matrix operator*(const Matrix& B) {\n        assert(B.n == m);\n        Matrix C = Matrix(n, B.m);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < B.m; j++)\n                for (int k = 0; k < m; k++)\n                    C.M[i][j] = (C.M[i][j] + 1LL * M[i][k] * B.M[k][j]) % mod;\n        return C;\n    }\n    Matrix operator*(const int& k) {\n        Matrix C = *this;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                C.M[i][j] = (C.M[i][j] * k) % mod;\n        return C;\n    }\n    Matrix operator+(const Matrix& B) {\n        assert(B.n == n && B.m == m);\n        Matrix C = Matrix(n, m);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                C.M[i][j] = (M[i][j] + B.M[i][j]) % mod;\n        return C;\n    }\n    Matrix operator-(const Matrix& B) {\n        assert(B.n == n && B.m == m);\n        Matrix C = Matrix(n, m);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                C.M[i][j] = (M[i][j] - B.M[i][j]) % mod;\n        return C;\n    }\n    Matrix exp(ll k) {\n        assert(m == n);\n        Matrix C = Matrix(n, n), A = *this;\n        for (int i = 0; i < n; i++) C.M[i][i]++;\n        while (k) {\n            if (k & 1) C = C * A;\n            A = A * A, k >>= 1;\n        }\n        return C;\n    }\n    friend ostream& operator<<(ostream& os, const Matrix& A) {\n    \tfor (int i = 0; i < n; i++) {\n        \tfor (int j = 0; j < m; j++)\n            \tos << M[i][j] << ' ';\n        \tos << '\\n';\n        }\n        return os;\n    }\n};",
        "description": "matrix-arithmetic",
        "scope": "cpp"
    },
    "modular-arithmetic": {
        "prefix": "modular-arithmetic",
        "body": "const int kMod = 998244353;\n// const int kMod = 1e9 + 7;\nstruct ModInt {\n\tlong long n;\n\tModInt(long long n = 0) : n(n % kMod) {}\n\tModInt operator+(const ModInt& oth) { return n + oth.n; }\n\tModInt operator-(const ModInt& oth) { return n - oth.n; }\n\tModInt operator*(const ModInt& oth) { return n * oth.n; }\n\tlong long get() { return n < 0 ? n + kMod : n; }\n\tfriend ostream& operator<<(ostream& os, ModInt const& a) { return os << ModInt(a.n).get(); }\n};\nModInt lgpow(ModInt b, int e = -1) {\n\tif (b.get() == 0) return 0;\n\tModInt r; e = e % (kMod - 1);\n\tif (e < 0) e += kMod - 1;\n\tfor (r = 1; e; e >>= 1, b = b * b)\n\t\tif (e & 1) r = r * b;\n\treturn r;\n}\nvector<ModInt> fact, invfact;\nvoid factorials(int n) {\n\tfact.resize(n + 1, 1);\n\tinvfact.resize(n + 1, 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfact[i] = fact[i - 1] * i;\n\tinvfact[n] = lgpow(fact[n]);\n\tfor (int i = n - 1; i >= 1; --i)\n\t\tinvfact[i] = invfact[i + 1] * (i + 1);\n}\nModInt choose(int n, int k) {\n\treturn fact[n] * invfact[k] * invfact[n - k];\n}",
        "description": "modular-arithmetic",
        "scope": "cpp"
    },
    "ntt": {
        "prefix": "ntt",
        "body": "const int mod = 998244353, g = 3;\n// For p < 2^30 there is also (5 << 25, 3), (7 << 26, 3),\n// (479 << 21, 3) and (483 << 21, 5). Last two are > 10^9.\nstruct num {\n    int v;\n    num(ll v_ = 0) : v(int(v_ % mod)) {\n        if (v < 0) v += mod;\n    }\n    explicit operator int() const { return v; }\n    num operator+(const num& b) { return num(v + b.v); }\n    num operator-(const num& b) { return num(v + mod - b.v); }\n    num operator*(const num& b) { return num(1LL * v * b.v); }\n    num pow(long long b_ = -1) {\n        if (v == 0) return 0;\n        int b = b_ % (mod - 1);\n        if (b < 0) b += mod - 1;\n        num r = 1, a = *this;\n        do {\n            if (b & 1) r = r * a;\n            a = a * a;\n        } while (b >>= 1);\n        return r;\n    }\n};\nvector<int> rev({0, 1});\nvector<num> rt(2, num(1));\nstruct poly {\n    static void init(int n) {\n        int rts = rt.size();\n        if (n <= rts) return;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n            rev[i] = (rev[i >> 1] | ((i & 1) * n)) >> 1;\n        rt.reserve(n);\n        for (int k = rts; k < n; k *= 2) {\n            rt.resize(2 * k);\n            num z = num(g).pow((mod - 1) / (2 * k));\n            for (int i = k / 2; i < k; i++)\n                rt[2 * i] = rt[i], rt[2 * i + 1] = rt[i] * z;\n        }\n    }\n    static void fft(vector<num>& a, int n) {\n        init(n);\n        int s = rev.size();\n        s = __builtin_ctz(s / n);\n        for (int i = 0; i < n; i++)\n            if (i < (rev[i] >> s))\n                swap(a[i], a[rev[i] >> s]);\n        for (int k = 1; k < n; k *= 2) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    num t = rt[j + k] * a[i + j + k];\n                    a[i + j + k] = a[i + j] - t;\n                    a[i + j] = a[i + j] + t;\n                }\n            }\n        }\n    }\n    static vector<num> inverse(vector<num>& a) {\n        if (a.empty()) return {};\n        vector<num> b(1);\n        b[0] = a[0].pow();\n        b.reserve(2 * a.size());\n        vector<num> fa;\n        while (b.size() < a.size()) {\n            int n = 2 * b.size();\n            b.resize(2 * n, 0);\n            if (fa.size() < 2 * n) fa.resize(2 * n);\n            fill(fa.begin(), fa.begin() + 2 * n, 0);\n            copy(a.begin(), a.begin() + min(n, (int)a.size()), fa.begin());\n            fft(b, 2 * n), fft(fa, 2 * n);\n            num d = num(2 * n).pow();\n            for (int i = 0; i < 2 * n; i++)\n                b[i] = b[i] * (num(2) - fa[i] * b[i]) * d;\n            reverse(b.begin() + 1, b.end());\n            fft(b, 2 * n);\n            b.resize(n);\n        }\n        b.resize(a.size());\n        return b;\n    }\n    static vector<num> multiply(vector<num> a, vector<num> b) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return {};\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        a.resize(n), b.resize(n);\n        fft(a, n), fft(b, n);\n        num d = num(n).pow();\n        for (int i = 0; i < n; i++)\n            a[i] = a[i] * b[i] * d;\n        reverse(a.begin() + 1, a.end());\n        fft(a, n);\n        a.resize(s);\n        return a;\n    }\n    vector<num> coef;\n    poly(vector<num> v = {}) { coef = v; }\n    poly& operator+=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] + b.coef[i];\n        return *this;\n    }\n    poly operator+(const poly& b) {\n        poly r = *this;\n        r += b;\n        return r;\n    }\n    poly& operator-=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] - b.coef[i];\n        return *this;\n    }\n    poly operator-(const poly& b) {\n        poly r = *this;\n        r -= b;\n        return r;\n    }\n    poly operator*(const poly& b) {\n        return poly(multiply(coef, b.coef));\n    }\n    poly& operator*=(const poly& b) {\n        coef = multiply(coef, b.coef);\n        return *this;\n    }\n    poly& operator*=(const num& b) {\n        for (num& x : coef) x = x * b;\n        return *this;\n    }\n    // Polynomial floor division; no leading 0's plz\n    poly& operator/=(poly b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) {\n            coef.clear();\n            return *this;\n        }\n        int s = sza - szb + 1;\n        reverse(coef.begin(), coef.end());\n        reverse(b.coef.begin(), b.coef.end());\n        coef.resize(s), b.coef.resize(s);\n        coef = multiply(coef, inverse(b.coef));\n        coef.resize(s);\n        reverse(coef.begin(), coef.end());\n        return *this;\n    }\n    poly operator/(const poly& b) {\n        poly r = *this;\n        r /= b;\n        return r;\n    }\n    poly& operator%=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza >= szb) {\n            poly c = *this;\n            c /= b;\n            c *= b;\n            coef.resize(szb - 1);\n            for (int i = 0; i < sza; i++)\n                coef[i] = coef[i] - c.coef[i];\n        }\n        return *this;\n    }\n    poly operator%(const poly& b) {\n        poly r = *this;\n        r %= b;\n        return r;\n    }\n    poly deriv() {\n        if (coef.empty()) return poly();\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza - 1);\n        for (int i = 1; i < sza; i++)\n            b.coef[i - 1] = coef[i] * i;\n        return b;\n    }\n    poly integ() {\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza + 1);\n        b.coef[1] = 1;\n        for (int i = 2; i <= sza; i++)\n            b.coef[i] = b.coef[mod % i] * (-mod / i);\n        for (int i = 1; i <= sza; i++)\n            b.coef[i] = coef[i - 1] * b.coef[i];\n        return b;\n    }\n    poly log() {  // coef[0] == 1\n        poly a = this->deriv();\n        poly b = poly(multiply(coef, inverse(a.coef)));\n        b = b.integ();\n        b.coef.resize(coef.size());\n        return b;\n    }\n    poly exp() {  // coef[0] == 0\n        poly b;\n        b.coef.assign(1, num(1));\n        if (coef.empty()) return b;\n        while (b.coef.size() < coef.size()) {\n            int sza = coef.size();\n            int szb = b.coef.size();\n            int n = min(szb * 2, sza);\n            b.coef.resize(n);\n            poly v;\n            v.coef.resize(n);\n            for (int i = 0; i < n; i++)\n                v.coef[i] = coef[i];\n            v -= b.log();\n            v.coef[0] = v.coef[0] + num(1);\n            b *= v;\n            b.coef.resize(n);\n        }\n        return b;\n    }\n    poly pow(int m) {  // m >= 0\n        poly b;\n        int sza = coef.size();\n        b.coef.resize(sza);\n        if (m == 0) {\n            b.coef[0] = 1;\n            return b;\n        }\n        int p = 0;\n        while (p < sza && coef[p].v == 0) ++p;\n        if (1LL * m * p >= sza) return b;\n        num mu = coef[p].pow(m), di = coef[p].pow();\n        poly c;\n        c.coef.resize(sza - m * p);\n        for (int i = 0; i < c.coef.size(); i++)\n            c.coef[i] = coef[i + p] * di;\n        c = c.log();\n        for (num& v : c.coef)\n            v = v * m;\n        c = c.exp();\n        for (int i = 0; i < c.coef.size(); i++)\n            b.coef[i + m * p] = c.coef[i] * mu;\n        return b;\n    }\n    vector<num> eval(const vector<num>& x) {\n        int n = x.size();\n        if (!n) return {};\n        vector<poly> up(2 * n);\n        for (int i = 0; i < n; i++) {\n            vector<num> tmp = {num(num(0) - x[i]), num(1)};\n            up[i + n] = poly(tmp);\n        }\n        for (int i = n - 1; i >= 1; i--)\n            up[i] = up[2 * i] * up[2 * i + 1];\n        vector<poly> down(2 * n);\n        down[1] = (*this) % up[1];\n        for (int i = 2; i < 2 * n; i++)\n            down[i] = down[i / 2] % up[i];\n        vector<num> y(n);\n        for (int i = 0; i < n; i++)\n            y[i] = down[i + n].coef[0];\n        return y;\n    }\n};\npoly interp(const vector<num>& x, const vector<num>& y) {\n    int n = x.size();\n    assert(n);\n    vector<poly> up(n * 2);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {num(num(0) - x[i]), num(1)};\n        up[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        up[i] = up[2 * i] * up[2 * i + 1];\n    vector<num> a = up[1].deriv().eval(x);\n    vector<poly> down(2 * n);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {a[i].pow() * y[i]};\n        down[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        down[i] = down[i * 2] * up[i * 2 + 1] + down[i * 2 + 1] * up[i * 2];\n    return down[1];\n}",
        "description": "number_theoretic_transform",
        "scope": "cpp"
    },
    "pbds": {
        "prefix": "pbds",
        "body": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate <class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the iterator to kth largest element.(0-based)",
        "description": "pbds",
        "scope": "cpp"
    },
    "pragmas": {
        "prefix": "pragmas",
        "body": "#pragma GCC optimize(\"O3\")\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")",
        "description": "pragma",
        "scope": "cpp"
    },
    "randoms": {
        "prefix": "randoms",
        "body": "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n#define shuf(v) shuffle((v).begin(), (v).end(), rng);\n// Use mt19937_64 for 64 bit random numbers.",
        "description": "random",
        "scope": "cpp"
    },
    "readfns": {
        "prefix": "readfns",
        "body": "inline int read() {int x; cin >> x; return x;}\ninline long long readl() {long long x; cin >> x; return x;}\ninline char readc() {char x; cin >> x; return x;}\ninline string reads() {string x; cin >> x; return x;}",
        "description": "read",
        "scope": "cpp"
    },
    "rmq_sparse_table": {
        "prefix": "rmq_sparse_table",
        "body": "template <typename T, bool maximum_mode = false>\nstruct RMQ {\n    int n = 0;\n    vector<T> values;\n    vector<vector<int>> range_low;\n    RMQ(const vector<T> &_values = {}) {\n        if (!_values.empty())\n            build(_values);\n    }\n    static int largest_bit(int x) {\n        return 31 - __builtin_clz(x);\n    }\n    // Note: when `values[a] == values[b]`, returns b.\n    int better_index(int a, int b) const {\n        return (maximum_mode ? values[b] < values[a] : values[a] < values[b]) ? a : b;\n    }\n    void build(const vector<T> &_values) {\n        values = _values;\n        n = int(values.size());\n        int levels = largest_bit(n) + 1;\n        range_low.resize(levels);\n        for (int k = 0; k < levels; k++)\n            range_low[k].resize(n - (1 << k) + 1);\n        for (int i = 0; i < n; i++)\n            range_low[0][i] = i;\n        for (int k = 1; k < levels; k++)\n            for (int i = 0; i <= n - (1 << k); i++)\n                range_low[k][i] = better_index(range_low[k - 1][i], range_low[k - 1][i + (1 << (k - 1))]);\n    }\n    // Note: breaks ties by choosing the largest index.\n    int query_index(int a, int b) const {\n        assert(0 <= a && a < b && b <= n);\n        int level = largest_bit(b - a);\n        return better_index(range_low[level][a], range_low[level][b - (1 << level)]);\n    }\n    T query_value(int a, int b) const {\n        return values[query_index(a, b)];\n    }\n};",
        "description": "rmq_sparse_table",
        "scope": "cpp"
    },
    "seg_tree_assignment_fast": {
        "prefix": "seg_tree_assignment_fast",
        "body": "struct seg_tree_assign {\n    vector<int> t, d;\n    vector<bool> dont;\n    int n, h;\n    seg_tree_assign() {}\n    void init(int m = 0) {\n        n = m;\n        h = 32 - __builtin_clz(n);\n        d.assign(n, 0);\n        dont.assign(n, true);\n        t.assign(2 * n, 0);\n    }\n    void calc(int p, int k) {\n        if (dont[p])\n            t[p] = t[p << 1] + t[p << 1 | 1];\n        else\n            t[p] = d[p] * k;\n    }\n    void apply(int p, int value, int k) {\n        t[p] = value * k;\n        if (p < n) d[p] = value, dont[p] = false;\n    }\n    void push_up(int l, int r) {\n        int k = 2;\n        for (l += n, r += n - 1; l > 1; k <<= 1) {\n            l >>= 1, r >>= 1;\n            for (int i = r; i >= l; --i) calc(i, k);\n        }\n    }\n    void push_down(int l, int r) {\n        int s = h, k = 1 << (h - 1);\n        for (l += n, r += n - 1; s > 0; --s, k >>= 1) {\n            for (int i = l >> s; i <= r >> s; ++i) {\n                if (dont[i]) continue;\n                apply(i << 1, d[i], k);\n                apply(i << 1 | 1, d[i], k);\n                d[i] = 0, dont[i] = true;\n            }\n        }\n    }\n    void assign(int l, int r, int value) {\n        if (r < l || r >= n || l < 0) return;\n        push_down(l, l + 1), push_down(r, r + 1);\n        bool cl = false, cr = false;\n        int k = 1;\n        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1, k <<= 1) {\n            if (cl) calc(l - 1, k);\n            if (cr) calc(r, k);\n            if (l & 1) apply(l++, value, k), cl = true;\n            if (r & 1) apply(--r, value, k), cr = true;\n        }\n        for (--l; r > 0; l >>= 1, r >>= 1, k <<= 1) {\n            if (cl) calc(l, k);\n            if (cr && (!cl || l != r)) calc(r, k);\n        }\n    }\n    int query(int l, int r) {\n        int res = 0;\n        if (r < l || r >= n || l < 0) return res;\n        push_down(l, l + 1), push_down(r, r + 1);\n        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res += t[l++];\n            if (r & 1) res += t[--r];\n        }\n        return res;\n    }\n};",
        "description": "segment_tree_assignment_iterative",
        "scope": "cpp"
    },
    "seg_tree_assignment_slow": {
        "prefix": "seg_tree_assignment_slow",
        "body": "struct seg_tree_assign {\n    vector<int> t, lazy;\n    vector<bool> dont;\n    int n;\n    void init(int m) {\n        n = m;\n        t.assign(4 * n, 0);\n        lazy.assign(4 * n, 0);\n        dont.assign(4 * n, true);\n    }\n    void push(int v, int k, bool leaf) {\n        if (!dont[v]) {\n            t[v] = lazy[v] * k;\n            if (!leaf) {\n                lazy[v * 2] = lazy[v * 2 + 1] = lazy[v];\n                dont[v * 2] = dont[v * 2 + 1] = false;\n            }\n            lazy[v] = 0, dont[v] = true;\n        }\n    }\n    void assign_aux(int v, int tl, int tr, int l, int r, int new_val) {\n        if (l > r) return push(v, tr - tl + 1, tl == tr);\n        if (l == tl && tr == r) {\n            lazy[v] = new_val, dont[v] = false;\n            push(v, tr - tl + 1, tl == tr);\n        } else {\n            push(v, tr - tl + 1, tl == tr);\n            int tm = (tl + tr) / 2;\n            assign_aux(v * 2, tl, tm, l, min(r, tm), new_val);\n            assign_aux(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, new_val);\n            t[v] = t[v * 2] + t[v * 2 + 1];\n        }\n    }\n    int query_aux(int v, int tl, int tr, int l, int r) {\n        push(v, tr - tl + 1, tl == tr);\n        if (l > r) return 0;\n        if (l == tl && tr == r) return t[v];\n        int tm = (tl + tr) / 2;\n        int ret = query_aux(v * 2, tl, tm, l, min(r, tm)) +\n                  query_aux(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n        t[v] = t[v * 2] + t[v * 2 + 1];\n        return ret;\n    }\n    void assign(int l, int r, int x) {\n        return assign_aux(1, 0, n - 1, l, r, x);\n    }\n    int query(int l, int r) {\n        return query_aux(1, 0, n - 1, l, r);\n    }\n};",
        "description": "segment_tree_assignment_recursive",
        "scope": "cpp"
    },
    "seg_tree_fast": {
        "prefix": "seg_tree_fast",
        "body": "template <class node>\nstruct seg_tree {\n    vector<node> t;\n    int n;\n    seg_tree() {}\n    void build(vector<int>& a) {\n        n = a.size();\n        t.resize(2 * n);\n        for (int i = 0; i < n; i++)\n            t[i + n] = node(a[i]);\n        for (int i = n - 1; i > 0; i--)\n            t[i] = t[i << 1] + t[i << 1 | 1];\n    }\n    void update(int p, int x) {  // on 0-indexed p\n        for (t[p += n] = node(x); p >>= 1;)\n            t[p] = t[p << 1] + t[p << 1 | 1];\n    }\n    node query(int l, int r) {  // interval [l,r]\n        node resl, resr;\n        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) resl = resl + t[l++];\n            if (r & 1) resr = t[--r] + resr;\n        }\n        return resl + resr;\n    }\n};",
        "description": "segment_tree_iterative",
        "scope": "cpp"
    },
    "seg_tree_lazy_fast": {
        "prefix": "seg_tree_lazy_fast",
        "body": "template <class node>\nstruct seg_tree_lazy {\n    vector<node> t, d;\n    int n, h;\n    seg_tree_lazy() {}\n    void init(int m = 0) {\n        n = m;\n        h = 32 - __builtin_clz(n);\n        d.resize(n);\n        t.resize(2 * n);\n    }\n    void apply(int p, node value, int c) {\n        if (p < n) d[p] = d[p] + value;\n        t[p] = t[p] + value * c;\n    }\n    void push_up(int p) {\n        for (int c = 2; p >>= 1; c <<= 1)\n            t[p] = t[p << 1] + t[p << 1 | 1] + d[p] * c;\n    }\n    void push_down(int p) {\n        for (int s = h; s > 0; --s) {\n            int i = p >> s;\n            if (d[i].or_val != 0) {\n                int c = 1 << (s - 1);\n                apply(i << 1, d[i], c);\n                apply(i << 1 | 1, d[i], c);\n                d[i].val = 1;\n                d[i].or_val = 0;\n            }\n        }\n    }\n    void add(int l, int r, int v) {\n        if (r < l || r >= n || l < 0) return;\n        l += n, r += n + 1;\n        int _l = l, _r = r;\n        node value(v);\n        for (int c = 1; l < r; l >>= 1, r >>= 1, c <<= 1) {\n            if (l & 1) apply(l++, value, c);\n            if (r & 1) apply(--r, value, c);\n        }\n        push_up(_l), push_up(_r - 1);\n    }\n    node query(int l, int r) {\n        node res;\n        if (r < l || r >= n || l < 0) return res;\n        l += n, r += n + 1;\n        push_down(l), push_down(r - 1);\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = res + t[l++];\n            if (r & 1) res = res + t[--r];\n        }\n        return res;\n    }\n};",
        "description": "segment_tree_lazy_iterative",
        "scope": "cpp"
    },
    "seg_tree_lazy_slow": {
        "prefix": "seg_tree_lazy_slow",
        "body": "template <class node>\nstruct seg_tree_lazy {\n    vector<node> t, lazy;\n    int n;\n    void init(int m) {\n        n = m;\n        t.resize(4 * n);\n        lazy.resize(4 * n);\n    }\n    void push(int v, int l, int r) {\n        lazy[v * 2] = lazy[v * 2] + lazy[v];\n        lazy[v * 2 + 1] = lazy[v * 2 + 1] + lazy[v];\n        t[v * 2] = t[v * 2] + lazy[v] * l;\n        t[v * 2 + 1] = t[v * 2 + 1] + lazy[v] * r;\n        lazy[v] = node();\n    }\n    void add_aux(int v, int tl, int tr, int l, int r, int addend) {\n        if (l > r) return;\n        if (l == tl && tr == r) {\n            t[v] = t[v] + node(addend) * (tr - tl + 1);\n            lazy[v] = lazy[v] + addend;\n        } else {\n            int tm = (tl + tr) / 2;\n            push(v, tm - tl + 1, tr - tm);\n            add_aux(v * 2, tl, tm, l, min(r, tm), addend);\n            add_aux(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);\n            t[v] = t[v * 2] + t[v * 2 + 1];\n        }\n    }\n    node query_aux(int v, int tl, int tr, int l, int r) {\n        if (l > r) return node();\n        if (l == tl && tr == r) return t[v];\n        int tm = (tl + tr) / 2;\n        push(v, tm - tl + 1, tr - tm);\n        return query_aux(v * 2, tl, tm, l, min(r, tm)) +\n               query_aux(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n    }\n    void add(int l, int r, int x) {\n        return add_aux(1, 0, n - 1, l, r, x);\n    }\n    node query(int l, int r) {\n        return query_aux(1, 0, n - 1, l, r);\n    }\n};",
        "description": "segment_tree_lazy_recursive",
        "scope": "cpp"
    },
    "seg_tree_slow": {
        "prefix": "seg_tree_slow",
        "body": "struct seg_tree {\n    vector<int> t;\n    int n;\n    void init(int m) {\n        n = m;\n        t.assign(4 * n, 0);\n    }\n    int query_aux(int v, int tl, int tr, int l, int r) {\n        if (l > r) return 0;\n        if (l == tl && r == tr) return t[v];\n        int tm = (tl + tr) / 2;\n        return query_aux(v * 2, tl, tm, l, min(r, tm)) +\n               query_aux(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n    }\n    void update_aux(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {\n            t[v] = new_val;\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        if (pos <= tm)\n            update_aux(v * 2, tl, tm, pos, new_val);\n        else\n            update_aux(v * 2 + 1, tm + 1, tr, pos, new_val);\n        t[v] = t[v * 2] + t[v * 2 + 1];\n    }\n    void update(int i, int x) {\n        return update_aux(1, 0, n - 1, i, x);\n    }\n    int query(int l, int r) {\n        return query_aux(1, 0, n - 1, l, r);\n    }\n};",
        "description": "segment_tree_recursive",
        "scope": "cpp"
    },
    "sieve": {
        "prefix": "sieve",
        "body": "const int N = 2e6 + 10;\nint least[N];\nvoid sieve() {\n\tleast[0] = 0; least[1] = 1;\n\tfor (int i = 2; i < N; i++)\n\t\tleast[i] = (i % 2) ? i : 2;\n\tfor (int i = 3; i * i <= N; i += 2) {\n\t\tif (least[i] != i) continue;\n\t\tfor (int j = i * i; j < N; j += i)\n\t\t\tif (least[j] == j)\n\t\t\t\tleast[j] = i;\n\t}\n}",
        "description": "sieve_of_eratosthenes",
        "scope": "cpp"
    },
    "sqrtdec": {
        "prefix": "sqrtdec",
        "body": "struct decomp {\n    vector<int> state, block, sums;\n    int n, rt;\n    decomp(int m) {\n        n = m;\n        rt = sqrtl(n) + 1;\n        block.assign(rt + 1, 0);\n        sums.assign(rt + 1, 0);\n        state.assign(n, 0);\n    }\n    void update(int i, int j) {\n        if (i > j) return;\n        if (i < 0) return update(0, j);\n        if (j >= n) return update(i, n - 1);\n        int ri = i / rt, rj = j / rt;\n        if (ri == rj) {\n            for (int it = i; it <= j; it++) {\n                state[it] = 1 - state[it];\n                int ch = 2 * state[it] - 1;\n                sums[ri] += block[ri] ? -ch : ch;\n            }\n            return;\n        }\n        for (int it = ++ri; it < rj; it++) {\n            sums[it] = rt - sums[it];\n            block[it] = 1 - block[it];\n        }\n        update(i, ri * rt - 1);\n        update(rj * rt, j);\n    }\n    int query(int i, int j) {\n        if (i > j) return 0;\n        if (i < 0) return query(0, j);\n        if (j >= n) return query(i, n - 1);\n        int ri = i / rt, rj = j / rt;\n        int ans = 0;\n        if (ri == rj) {\n            for (int it = i; it <= j; it++)\n                ans += block[ri] ? (1 - state[it]) : state[it];\n            return ans;\n        }\n        for (int it = ++ri; it < rj; it++)\n            ans += sums[it];\n        ans += query(i, ri * rt - 1);\n        ans += query(rj * rt, j);\n        return ans;\n    }\n};",
        "description": "sqrt-decomposition",
        "scope": "cpp"
    },
    "suffix_array": {
        "prefix": "suffix_array",
        "body": "struct suf_array {\n    int n, alphabet = 256;\n    string s;\n    bool store_cc;\n    vector<int> p, c, cnt, base_lcp, logs;\n    vector<vector<int>> st, cc;\n    suf_array() {}\n    void build_suf_array() {\n        // base case k = 0\n        // count sort\n        for (int i = 0; i < n; i++)\n            cnt[s[i]]++;\n        for (int i = 1; i < alphabet; i++)\n            cnt[i] += cnt[i - 1];\n        for (int i = 0; i < n; i++)\n            p[--cnt[s[i]]] = i;\n        // calculate equivalence classes\n        c[p[0]] = 0;\n        int classes = 1;\n        for (int i = 1; i < n; i++) {\n            if (s[p[i]] != s[p[i - 1]])\n                classes++;\n            c[p[i]] = classes - 1;\n        }\n        if (store_cc)\n            cc.push_back(c);\n        // transition k -> k + 1\n        vector<int> pn(n), cn(n);\n        for (int h = 0, dh = 1; (1 << h) < n; ++h, dh <<= 1) {\n            // back shift\n            for (int i = 0; i < n; i++) {\n                pn[i] = p[i] - dh;\n                if (pn[i] < 0) pn[i] += n;\n            }\n            // count sort\n            fill(cnt.begin(), cnt.begin() + classes, 0);\n            for (int i = 0; i < n; i++)\n                cnt[c[pn[i]]]++;\n            for (int i = 1; i < classes; i++)\n                cnt[i] += cnt[i - 1];\n            for (int i = n - 1; i >= 0; i--)\n                p[--cnt[c[pn[i]]]] = pn[i];\n            // recalculate equivalence classes\n            cn[p[0]] = 0, classes = 1;\n            pair<int, int> prv = {c[p[0]], c[(p[0] + dh) % n]};\n            for (int i = 1; i < n; i++) {\n                pair<int, int> cur = {c[p[i]], c[(p[i] + dh) % n]};\n                if (cur != prv)\n                    ++classes;\n                cn[p[i]] = classes - 1;\n                prv = cur;\n            }\n            if (store_cc)\n                cc.push_back(cn);\n            c.swap(cn);\n        }\n    }\n    void build_lcp() {\n        int k = 0;\n        // base_lcp[0] is useless\n        base_lcp.assign(n, 0);\n        for (int i = 0; i < n - 1; i++) {\n            int j = p[c[i] - 1];\n            while (i + k < n &&\n                   j + k < n &&\n                   s[i + k] == s[j + k])\n                k++;\n            base_lcp[c[i]] = k;\n            k = max(k - 1, 0);\n        }\n    }\n    void build_logs() {\n        // precalculation logs[i] = int(log2(i))\n        logs.assign(n + 1, 0);\n        for (int i = 2; i <= n; i++)\n            logs[i] = logs[i / 2] + 1;\n    }\n    void build_sparse_table() {\n        // sparse table building\n        st.assign(n, vector<int>(logs[n] + 1));\n        for (int i = 0; i < n; i++)\n            st[i][0] = base_lcp[i];\n        for (int j = 1; j <= logs[n]; j++)\n            for (int i = 0; i + (1 << j) <= n; i++)\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n    }\n    void build(const string& ss, char sentinel = char(36)) {\n        s = ss + sentinel;\n        n = s.size();\n        p.resize(n);\n        c.resize(n);\n        cnt.assign(max(n, alphabet), 0);\n        store_cc = false;\n        build_suf_array();\n        build_lcp();\n        // build_logs();\n        // build_sparse_table();\n    }\n    pair<int, int> repr(int i, int l) {\n        // returns pair representation of prefix\n        // of length l if i-th suffix\n        assert(store_cc);\n        int k = logs[l];\n        return make_pair(cc[k][i], cc[k][(i + l - (1 << k)) % n]);\n    }\n    int lcp(int i, int j) {\n        // lcp of i-th suffix and j-th suffix, 0-indexed\n        // i, j are original indices, not in p!\n        if (i == j) return n - i - 1;\n        int L = c[i], R = c[j];\n        if (R < L) swap(R, L);\n        int len = logs[R - L];\n        L++, R++;\n        int mn = min(st[L][len], st[R - (1 << len)][len]);\n        return mn;\n    }\n    int lower_bound(const string& t) {\n        int k = t.size();\n        int lo = 0, hi = n, mid;\n        while (lo < hi - 1) {\n            mid = lo + (hi - lo) / 2;\n            if (s.substr(p[mid], k) < t)\n                lo = mid;\n            else\n                hi = mid;\n        }\n        return hi;\n    }\n    int upper_bound(const string& t) {\n        int k = t.size();\n        int lo = 0, hi = n, mid;\n        while (lo < hi - 1) {\n            mid = lo + (hi - lo) / 2;\n            if (s.substr(p[mid], k) <= t)\n                lo = mid;\n            else\n                hi = mid;\n        }\n        return hi;\n    }\n    void print(int w = 5) {\n        for (int i = 1; i < n; i++) {\n            cerr << left << setw(w) << p[i]\n                 << setw(w) << base_lcp[i]\n                 << s.substr(p[i], n - p[i] - 1) << '\\n';\n        }\n    }\n};",
        "description": "suffix_array",
        "scope": "cpp"
    },
    "template_extended": {
        "prefix": "template_extended",
        "body": "// #pragma GCC optimize(\"O3\")\n// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <ratio>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n#ifdef LOCAL\n#include \"trace.h\"\n#else\n#define trace(args...)\n#endif\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\ntypedef pair<int, int> pi;\ntypedef pair<long long, long long> pl;\ntypedef pair<long double, long double> pd;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<long double> vd;\ntypedef vector<string> vs;\ntypedef vector<pair<ll, ll>> vpl;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n        tree_order_statistics_node_update> ordered_set;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the iterator to kth largest element.(0-based)\n\n#define forn(i, a, b) for (int i = (a); i <= (b); i++)\n#define rfor(i, b, a) for (int i = (b); i >= (a); i--)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forv(i, v) for (auto& (i) : (v))\n#define trav(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n\n#define all(v) (v).begin(), (v).end()\n#define sz(v) (int)(v).size()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pc(c) putchar(c)\n#define gc(c) getchar(c)\n#define runtime() (int)(1000 * ((double)clock()) / CLOCKS_PER_SEC)\n#define flush() cout << flush\n#define max_queue(t) priority_queue<t>\n#define min_queue(t) priority_queue<t,vector<t>,greater<t>>\n\n#define popcnt __builtin_popcount\n#define popcntll __builtin_popcountll\n#define ctz __builtin_ctz\n#define ctzll __builtin_ctzll\n\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define ef emplace_front\n#define eb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define rsz resize\n#define ins insert\n#define endl \"\\n\"\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n#define shuf(v) shuffle((v).begin(), (v).end(), rng);\n// Use mt19937_64 for 64 bit random numbers.\n\n#define Set(n, i) n = (n) | (1LL << (i))\n#define Reset(n, i) n = (n) & ~(1LL << (i))\n#define Test(n, i) ((n) >> (i) & 1LL)\n#define par(n) (n) & 1LL\n\ninline int read() {int x; cin >> x; return x;}\ninline long long readl() {long long x; cin >> x; return x;}\ninline char readc() {char x; cin >> x; return x;}\ninline string reads() {string x; cin >> x; return x;}\n\nconst double Pi = 3.1415926535898;\ninline void solve();\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif\n    cout << fixed << setprecision(10);\n    int t = 1;\n    // cin >> t;\n    for (int i = 1; i <= t; i++) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n    }\n#ifdef LOCAL\n    cout << \"\\nTime Elapsed: \" << runtime() << \" ms\\n\";\n#endif\n    return 0;\n}\n//------------------------------------------ end -----------------------------------------------//\nconst int N = 1e9 + 7;\nconst int mod = 998244353;\ninline void solve() {\n\n}",
        "description": "template_extended",
        "scope": "cpp"
    },
    "trie_suffix": {
        "prefix": "trie_suffix",
        "body": "const int K = 26;\nconst int def = -1;\nint root = 0;\nstruct Vertex {\n    int nxt[K], go[K];\n    bool leaf = false;\n    int par = def, link = def;\n    char pch = '$';\n    Vertex(int par = def, char ch = '$') : par(par), pch(ch) {\n        fill(begin(nxt), end(nxt), def);\n        fill(begin(go), end(go), def);\n    }\n};\nvector<Vertex> trie(1);\nvoid add_string(int v = root, string const& s) {\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (trie[v].nxt[c] == def) {\n            trie[v].nxt[c] = trie.size();\n            trie.emplace_back(v, ch);\n        }\n        v = trie[v].nxt[c];\n    }\n    trie[v].leaf = true;\n}\nint go(int v, char ch);\nint get_link(int v) {\n    if (trie[v].link != def)\n        return trie[v].link;\n    if (v == root || trie[v].par == root)\n        trie[v].link = root;\n    else\n        trie[v].link = go(get_link(trie[v].par), trie[v].pch);\n    return trie[v].link;\n}\nint go(int v, char ch) {\n    int c = ch - 'a';\n    if (trie[v].go[c] != def)\n        return trie[v].go[c];\n    if (trie[v].nxt[c] != def)\n        trie[v].go[c] = trie[v].nxt[c];\n    else if (v == root)\n        trie[v].go[c] = root;\n    else\n        trie[v].go[c] = go(get_link(v), ch);\n    return trie[v].go[c];\n}\nvoid dfs(int v) {\n    for (int i = 0; i < K; i++) {\n        if (trie[v].nxt[i] == def) continue;\n        dfs(trie[v].nxt[i]);\n    }\n}",
        "description": "trie_with_suffix_links",
        "scope": "cpp"
    },
    "types": {
        "prefix": "types",
        "body": "typedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\ntypedef pair<int, int> pi;\ntypedef pair<long long, long long> pl;\ntypedef pair<long double, long double> pd;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<long double> vd;\ntypedef vector<string> vs;\ntypedef vector<pair<ll, ll>> vpl;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n        tree_order_statistics_node_update> ordered_set;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the iterator to kth largest element.(0-based)",
        "description": "typedefs",
        "scope": "cpp"
    },
    "dsu": {
        "prefix": "dsu",
        "body": "vector<int> siz, par;\nint root(int a) {\n\tif (par[a] == -1) par[a] = a;\n\tint _a = a;\n\twhile (a != par[a]) a = par[a];\n\tpar[_a] = a;\n\treturn a;\n}\nvoid add(int a, int b) {\n\ta = root(a); b = root(b);\n\tif (a == b) return;\n\tif (siz[a] < siz[b]) swap(a, b);\n\tsiz[a] += siz[b];\n\tpar[b] = a;\n}",
        "description": "unionfind",
        "scope": "cpp"
    }
}