{
    "macros": {
        "prefix": "macros",
        "body": "#define forn(i, a, b) for (int i = (a); i <= (b); i++)\n#define rfor(i, b, a) for (int i = (b); i >= (a); i--)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forv(i, v) for (auto& (i) : (v))\n#define trav(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n\n#define all(v) (v).begin(), (v).end()\n#define sz(v) (int)(v).size()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pc(c) putchar(c)\n#define gc(c) getchar(c)\n#define runtime() (int)(1000 * ((double)clock()) / CLOCKS_PER_SEC)\n#define flush() cout << flush\n#define max_queue(t) priority_queue<t>\n#define min_queue(t) priority_queue<t,vector<t>,greater<t>>\n\n#define popcnt __builtin_popcount\n#define popcntll __builtin_popcountll\n#define ctz __builtin_ctz\n#define ctzll __builtin_ctzll\n\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define ef emplace_front\n#define eb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define rsz resize\n#define ins insert\n#define endl \"\\n\"",
        "description": "macros",
        "scope": "cpp"
    },
    "basic": {
        "prefix": "basic",
        "body": "typedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<int, int> pi;\ntypedef pair<long long, long long> pl;\ntypedef vector<int> vi;\n#define forn(i, a, b) for (int i = (a); i <= (b); i++)\n#define rfor(i, b, a) for (int i = (b); i >= (a); i--)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) (int)(v).size()\n#define rall(v) (v).rbegin(), (v).rend()\n#define runtime() (int)(1000 * ((double)clock()) / CLOCKS_PER_SEC)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define endl \"\\n\"",
        "description": "basic",
        "scope": "cpp"
    },
    "bitmasks": {
        "prefix": "bitmasks",
        "body": "#define Set(n, i) n = (n) | (1LL << (i))\n#define Reset(n, i) n = (n) & ~(1LL << (i))\n#define Test(n, i) ((n) >> (i) & 1LL)\n#define par(n) (n) & 1LL",
        "description": "bitmasks",
        "scope": "cpp"
    },
    "closest": {
        "prefix": "closest",
        "body": "ll dist(pii u, pii v) {\n    u.fi -= v.fi, u.se -= v.se;\n    ll cur = 1LL * u.fi * u.fi + 1LL * u.se * u.se;\n    return cur;\n}\nll rec(int l, int r) {\n    ll mn = LLONG_MAX;\n    if (r - l <= 3) {\n        for (int i = l; i < r; ++i)\n            for (int j = i + 1; j < r; ++j)\n                mn = min(mn, dist(a[i], a[j]));\n        for (int i = l; i < r; ++i)\n            swap(a[i].fi, a[i].se);\n        sort(a.begin() + l, a.begin() + r);\n        return mn;\n    }\n    int m = (l + r) / 2, tsz = 0;\n    int midx = a[m].fi;\n    mn = min(rec(l, m), rec(m, r));\n    vector<pii> t(r - l);\n    auto it = a.begin();\n    merge(it + l, it + m, it + m, it + r, t.begin());\n    copy(t.begin(), t.end(), a.begin() + l);\n    int rt = sqrtl(mn) + 1;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].se - midx) >= rt) continue;\n        for (int j = tsz - 1; j >= 0 && a[i].fi - t[j].fi < rt; --j)\n            mn = min(mn, dist(a[i], t[j]));\n        t[tsz++] = a[i];\n    }\n    return mn;\n}\nll ClosestPair(vector<pii> pts) {\n    int n = pts.size();\n    sort(pts.begin(), pts.end());\n    set<pii> s;\n    ll ans = LLONG_MAX;\n    int j = 0;\n    for (pii p : pts) {\n        int d = ceil(sqrtl(ans));\n        while (p.fi - pts[j].fi >= ans) {\n            s.erase({pts[j].se, pts[j].fi});\n            j++;\n        }\n        auto it1 = s.lower_bound({p.se - d, p.fi});\n        auto it2 = s.upper_bound({p.se + d, p.fi});\n        for (auto it = it1; it != it2; ++it)\n            ans = min(ans, dist(p, *it));      \n        s.insert({p.se, p.fi}); \n    }\n    return ans;\n}",
        "description": "closestPoints",
        "scope": "cpp"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": "using ll = long long;\nconst ll inf = 1e18;\nvector<ll> dist, parent;\nvector<vector<pair<ll, ll>>> adj;\nvoid dijkstra(int s, int n) {\n\tusing pi = pair<ll, ll>;\n\tpriority_queue<pi> pq;\n\tdist.resize(n, inf);\n\tparent.resize(n, -1);\n\tpq.push(make_pair(0, s));\tdist[s] = 0;\n\twhile (!pq.empty()) {\n\t\tll v = pq.top().second;\n\t\tll d = -pq.top().first;\n\t\tpq.pop();\n\t\tif (d > dist[v]) continue;\n\t\tfor (pi p : adj[v]) {\n\t\t\tll u = p.first, w = p.second;\n\t\t\tif (dist[v] + w < dist[u]) {\n\t\t\t\tdist[u] = dist[v] + w;      // update the distance\n\t\t\t\tparent[u] = v;        // for extracting the shortest path\n\t\t\t\tpq.push(make_pair(-dist[u], u));\n\t\t\t}\n\t\t}\n\t}\n}",
        "description": "dijkstra",
        "scope": "cpp"
    },
    "fastio": {
        "prefix": "fastio",
        "body": "ios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);",
        "description": "fastio",
        "scope": "cpp"
    },
    "fft": {
        "prefix": "fft",
        "body": "using ll = long long;\nusing ld = double;\nstruct num {\n    ld x, y;\n    num(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}\n    num operator+(const num& b) { return num(x + b.x, y + b.y); }\n    num operator-(const num& b) { return num(x - b.x, y - b.y); }\n    num operator*(const num& b) { return num(x * b.x - y * b.y, x * b.y + y * b.x); }\n    num conj() { return num(x, -y); }\n    num pow(ll b = -1) {\n        if (x == 0 && y == 0) return num(0, 0);\n        if (b < 0) {\n            ld n = (x * x + y * y);\n            return num(x / n, -y / n).pow(-b);\n        }\n        num r = num(1, 0), a = *this;\n        do {\n            if (b & 1) r = r * a;\n            a = a * a;\n        } while (b >>= 1);\n        return r;\n    }\n};\nvector<int> rev({0, 1});\nvector<num> rt(2, num(1));\nstruct poly {\n    static void init(int n) {\n        int rts = rt.size();\n        if (n <= rts) return;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n            rev[i] = (rev[i >> 1] | ((i & 1) * n)) >> 1;\n        rt.reserve(n);\n        for (int k = rts; k < n; k *= 2) {\n            rt.resize(2 * k);\n            ld a = M_PI / k;\n            num z = num(cos(a), sin(a));\n            for (int i = k / 2; i < k; i++)\n                rt[2 * i] = rt[i], rt[2 * i + 1] = rt[i] * z;\n        }\n    }\n    static void fft(vector<num>& a, int n) {\n        init(n);\n        int s = rev.size();\n        s = __builtin_ctz(s / n);\n        for (int i = 0; i < n; i++)\n            if (i < (rev[i] >> s))\n                swap(a[i], a[rev[i] >> s]);\n        for (int k = 1; k < n; k *= 2) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    num t = rt[j + k] * a[i + j + k];\n                    a[i + j + k] = a[i + j] - t;\n                    a[i + j] = a[i + j] + t;\n                }\n            }\n        }\n    }\n    static vector<num> inverse(vector<num>& a) {\n        if (a.empty()) return {};\n        vector<num> b(1);\n        b[0] = a[0].pow();\n        b.reserve(2 * a.size());\n        vector<num> fa;\n        while (b.size() < a.size()) {\n            int n = 2 * b.size();\n            b.resize(2 * n, 0);\n            if (fa.size() < 2 * n) fa.resize(2 * n);\n            fill(fa.begin(), fa.begin() + 2 * n, 0);\n            copy(a.begin(), a.begin() + min(n, (int)a.size()), fa.begin());\n            fft(b, 2 * n), fft(fa, 2 * n);\n            num d = num(2 * n).pow();\n            for (int i = 0; i < 2 * n; i++)\n                b[i] = b[i] * (num(2) - fa[i] * b[i]) * d;\n            reverse(b.begin() + 1, b.end());\n            fft(b, 2 * n);\n            b.resize(n);\n        }\n        b.resize(a.size());\n        return b;\n    }\n    static vector<num> multiply(vector<num> a, vector<num> b) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return {};\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        a.resize(n), b.resize(n);\n        fft(a, n), fft(b, n);\n        num d = num(n).pow();\n        for (int i = 0; i < n; i++)\n            a[i] = a[i] * b[i] * d;\n        reverse(a.begin() + 1, a.end());\n        fft(a, n);\n        a.resize(s);\n        return a;\n    }\n    static vector<ld> multiply(const vector<ld>& a, const vector<ld>& b) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return vector<ld>();\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        vector<num> fa(n), fb(n);\n        fill(fa.begin(), fa.begin() + n, num(0, 0));\n        for (int i = 0; i < sza; i++)\n            fa[i].x = a[i];\n        for (int i = 0; i < szb; i++)\n            fa[i].y = b[i];\n        fft(fa, n);\n        for (num& x : fa) x = x * x;\n        for (int i = 0; i < n; i++)\n            fb[i] = fa[(n - i) & (n - 1)] - conj(fa[i]);\n        fft(fb, n);\n        vector<ld> r(s);\n        for (int i = 0; i < s; i++)\n            r[i] = fb[i].y / (4 * n);\n        return r;\n    }\n    // Integer multiply mod m (num = complex) /// start-hash\n    static vector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return vector<int>();\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        vector<num> fa(n), fb(n);\n        for (int i = 0; i < sza; i++)\n            fa[i] = num(a[i] & ((1 << 15) - 1), a[i] >> 15);\n        fill(fa.begin() + sza, fa.begin() + n, num(0, 0));\n        for (int i = 0; i < szb; i++)\n            fb[i] = num(b[i] & ((1 << 15) - 1), b[i] >> 15);\n        fill(fb.begin() + szb, fb.begin() + n, num(0, 0));\n        fft(fa, n), fft(fb, n);\n        ld r0 = 0.5 / n;\n        for (int i = 0; i <= n / 2; i++) {\n            int j = (n - i) & (n - 1);\n            num g0 = (fb[i] + conj(fb[j])) * r0;\n            num g1 = (fb[i] - conj(fb[j])) * r0;\n            swap(g1.x, g1.y);\n            g1.y *= -1;\n            if (j != i) {\n                swap(fa[j], fa[i]);\n                fb[j] = fa[j] * g1;\n                fa[j] = fa[j] * g0;\n            }\n            fb[i] = fa[i] * conj(g1);\n            fa[i] = fa[i] * conj(g0);\n        }\n        fft(fa, n), fft(fb, n);\n        vector<int> r(s, 0);\n        for (int i = 0; i < s; i++)\n            r[i] = int((ll(fa[i].x + 0.5) + (ll(fa[i].y + 0.5) % m << 15) + (ll(fb[i].x + 0.5) % m << 15) + (ll(fb[i].y + 0.5) % m << 30)) % m);\n        return r;\n    }\n    vector<num> coef;\n    poly(vector<num> v = {}) { coef = v; }\n    poly& operator+=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] + b.coef[i];\n        return *this;\n    }\n    poly operator+(const poly& b) {\n        poly r = *this;\n        r += b;\n        return r;\n    }\n    poly& operator-=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] - b.coef[i];\n        return *this;\n    }\n    poly operator-(const poly& b) {\n        poly r = *this;\n        r -= b;\n        return r;\n    }\n    poly operator*(const poly& b) {\n        return poly(multiply(coef, b.coef));\n    }\n    poly& operator*=(const poly& b) {\n        coef = multiply(coef, b.coef);\n        return *this;\n    }\n    poly& operator*=(const num& b) {\n        for (num& x : coef) x = x * b;\n        return *this;\n    }\n    // Polynomial floor division; no leading 0's plz\n    poly& operator/=(poly b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) {\n            coef.clear();\n            return *this;\n        }\n        int s = sza - szb + 1;\n        reverse(coef.begin(), coef.end());\n        reverse(b.coef.begin(), b.coef.end());\n        coef.resize(s), b.coef.resize(s);\n        coef = multiply(coef, inverse(b.coef));\n        coef.resize(s);\n        reverse(coef.begin(), coef.end());\n        return *this;\n    }\n    poly operator/(const poly& b) {\n        poly r = *this;\n        r /= b;\n        return r;\n    }\n    poly& operator%=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza >= szb) {\n            poly c = *this;\n            c /= b;\n            c *= b;\n            coef.resize(szb - 1);\n            for (int i = 0; i < sza; i++)\n                coef[i] = coef[i] - c.coef[i];\n        }\n        return *this;\n    }\n    poly operator%(const poly& b) {\n        poly r = *this;\n        r %= b;\n        return r;\n    }\n    poly deriv() {\n        if (coef.empty()) return poly();\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza - 1);\n        for (int i = 1; i < sza; i++)\n            b.coef[i - 1] = coef[i] * i;\n        return b;\n    }\n    poly integ() {\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza + 1);\n        b.coef[1] = 1;\n        for (int i = 1; i <= sza; i++)\n            b.coef[i] = coef[i - 1] * num(i).pow();\n        return b;\n    }\n    poly log() {  // coef[0] == 1\n        poly a = this->deriv();\n        poly b = poly(multiply(coef, inverse(a.coef)));\n        b = b.integ();\n        b.coef.resize(coef.size());\n        return b;\n    }\n    poly exp() {  // coef[0] == 0\n        poly b;\n        b.coef.assign(1, num(1));\n        if (coef.empty()) return b;\n        while (b.coef.size() < coef.size()) {\n            int sza = coef.size();\n            int szb = b.coef.size();\n            int n = min(szb * 2, sza);\n            b.coef.resize(n);\n            poly v;\n            v.coef.resize(n);\n            for (int i = 0; i < n; i++)\n                v.coef[i] = coef[i];\n            v -= b.log();\n            v.coef[0] = v.coef[0] + num(1);\n            b *= v;\n            b.coef.resize(n);\n        }\n        return b;\n    }\n    poly pow(int m) {  // m >= 0\n        poly b;\n        int sza = coef.size();\n        b.coef.resize(sza);\n        if (m == 0) {\n            b.coef[0] = 1;\n            return b;\n        }\n        int p = 0;\n        while (p < sza && coef[p].v == 0) ++p;\n        if (1LL * m * p >= sza) return b;\n        num mu = coef[p].pow(m), di = coef[p].pow();\n        poly c;\n        c.coef.resize(sza - m * p);\n        for (int i = 0; i < c.coef.size(); i++)\n            c.coef[i] = coef[i + p] * di;\n        c = c.log();\n        for (num& v : c.coef)\n            v = v * m;\n        c = c.exp();\n        for (int i = 0; i < c.coef.size(); i++)\n            b.coef[i + m * p] = c.coef[i] * mu;\n        return b;\n    }\n    vector<num> eval(const vector<num>& x) {\n        int n = x.size();\n        if (!n) return {};\n        vector<poly> up(2 * n);\n        for (int i = 0; i < n; i++) {\n            vector<num> tmp = {num(num(0) - x[i]), num(1)};\n            up[i + n] = poly(tmp);\n        }\n        for (int i = n - 1; i >= 1; i--)\n            up[i] = up[2 * i] * up[2 * i + 1];\n        vector<poly> down(2 * n);\n        down[1] = (*this) % up[1];\n        for (int i = 2; i < 2 * n; i++)\n            down[i] = down[i / 2] % up[i];\n        vector<num> y(n);\n        for (int i = 0; i < n; i++)\n            y[i] = down[i + n].coef[0];\n        return y;\n    }\n};\npoly interp(const vector<num>& x, const vector<num>& y) {\n    int n = x.size();\n    assert(n);\n    vector<poly> up(n * 2);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {num(num(0) - x[i]), num(1)};\n        up[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        up[i] = up[2 * i] * up[2 * i + 1];\n    vector<num> a = up[1].deriv().eval(x);\n    vector<poly> down(2 * n);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {a[i].pow() * y[i]};\n        down[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        down[i] = down[i * 2] * up[i * 2 + 1] + down[i * 2 + 1] * up[i * 2];\n    return down[1];\n}",
        "description": "fast_fourier_transform",
        "scope": "cpp"
    },
    "seg_fast": {
        "prefix": "seg_fast",
        "body": "struct segtree {\n    vector<int> t;\n    int n;\n    segtree() {}\n    int combine(int a, int b) {\n        return max(a, b);\n    }\n    void build(vector<int>& a) {\n        n = a.size();\n        t.resize(2 * n);\n        for (int i = 0; i < n; i++)\n            t[i + n] = a[i];\n        for (int i = n - 1; i > 0; i--)\n            t[i] = combine(t[i << 1], t[i << 1 | 1]);\n    }\n    void update(int p, int x) {  // on 0-indexed p\n        for (t[p += n] = x; p >>= 1;)\n            t[p] = combine(t[p << 1], t[p << 1 | 1]);\n    }\n    int query(int l, int r) {  // interval [l,r]\n        int resl = 0, resr = 0;\n        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) resl = combine(resl, t[l++]);\n            if (r & 1) resr = combine(t[--r], resr);\n        }\n        return combine(resl, resr);\n    }\n};",
        "description": "fast_seg_tree",
        "scope": "cpp"
    },
    "fenwick": {
        "prefix": "fenwick",
        "body": "vector<int> B1, B2;\nvoid add(vector<int>& B, int i, int x) {\n    int n = B.size();\n    for (; i < n; i += i & (-i))\n        B[i] = B[i] + x;\n}\nint sum(vector<int>& B, int i) {\n    int sum = 0;\n    for (; i > 0; i -= i & (-i))\n        sum = sum + B[i];\n    return sum;\n}\nint get(vector<int>& B, int i) {\n    if (i <= 0) return 0;\n    int val = B[i];\n    int z = i - (i & -i);\n    for (--i; i != z; i -= i & (-i))\n        val = val - B[i];\n    return val;\n}\nint bit_search(vector<int>& B, int val) {\n\tint sum = 0, pos = 0, s = B.size();\n\tfor (int i = log2(s); i >= 0; i--) {\n\t\tint d = (1 << i);\n\t\tif (pos + d < s && sum + B[pos + d] < val){\n\t\t\tpos = pos + d;\n\t\t\tsum = sum + B[pos];\n\t\t}\n\t}\n\treturn pos + 1;\n}\nvoid range_add(int l, int r, int x) {\n    if (r < l) return;\n    add(B1, l, x);\n    add(B1, r + 1, -x);\n    add(B2, l, x * (l - 1));\n    add(B2, r + 1, -x * r);\n}\nint range_sum(int l, int r) {\n    int res = 0;\n    if (r < l) return res;\n    res = res + sum(B1, r) * r;\n    res = res - sum(B2, r);\n    res = res + sum(B1, (l - 1)) * (l - 1);\n    res = res - sum(B2, (l - 1));\n    return res;\n}",
        "description": "fenwick",
        "scope": "cpp"
    },
    "freopen": {
        "prefix": "freopen",
        "body": "#ifdef LOCAL\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif",
        "description": "freopen",
        "scope": "cpp"
    },
    "hashing": {
        "prefix": "hashing",
        "body": "typedef unsigned int uint;\ntemplate<typename T>\nuint vec_hash (const vector<T>& vec) {\n\tuint seed = vec.size();\n\tfor (T i : vec)\n\t\tseed ^= (uint)i + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n\treturn seed;\n}\nuint str_hash (const string s) {\n\tuint seed = s.size();\n\tfor (char i : vec)\n\t\tseed ^= (uint)i + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n\treturn seed;\n}",
        "description": "hash",
        "scope": "cpp"
    },
    "headers": {
        "prefix": "headers",
        "body": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <ratio>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;",
        "description": "headers",
        "scope": "cpp"
    },
    "kmp": {
        "prefix": "kmp",
        "body": "int kmp(string const& s) {\n    int n = s.size();\n    vector<int> lps(n, 0);\n    for (int i = 1; i < n; i++) {\n        int j = lps[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = lps[j - 1];\n        if (s[i] == s[j]) j++;\n        lps[i] = j;\n    }\n    return lps.back();\n}\nvoid kmp_aut(string s, vector<vector<int>>& aut) {\n    s += '#';\n    char base = 'a';\n    int n = s.size();\n    vector<int> pi = kmp(s);\n    aut.assign(n, vector<int>(26));\n    for (int i = 0; i < n; i++) {\n        for (int c = 0; c < 26; c++) {\n            if (i > 0 && base + c != s[i])\n                aut[i][c] = aut[pi[i - 1]][c];\n            else\n                aut[i][c] = i + (base + c == s[i]);\n        }\n    }\n}",
        "description": "kmp",
        "scope": "cpp"
    },
    "seg_fast_lazy": {
        "prefix": "seg_fast_lazy",
        "body": "struct segtree {\n    vector<ll> t, d;\n    int n, h;\n    segtree(int m) {\n        n = m;\n        h = 32 - __builtin_clz(n);\n        d.assign(n, 0);\n        t.assign(2 * n, 0);\n    }\n    void apply(int p, ll value) {\n        t[p] += value;\n        if (p < n) d[p] += value;\n    }\n    void build(int p) {\n        while (p >>= 1)\n            t[p] = t[p << 1] + t[p << 1 | 1] + d[p];\n    }\n    void push(int p) {\n        for (int s = h; s > 0; --s) {\n            int i = p >> s;\n            if (d[i] != 0) {\n                apply(i << 1, d[i]);\n                apply(i << 1 | 1, d[i]);\n                d[i] = 0;\n            }\n        }\n    }\n    void add(int l, int r, ll value) {\n        l += n, r += n + 1;\n        int _l = l, _r = r;\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) apply(l++, value);\n            if (r & 1) apply(--r, value);\n        }\n        build(_l), build(_r - 1);\n    }\n    ll query(int l, int r) {\n        l += n, r += n + 1;\n        push(l), push(r - 1);\n        ll res = 0;\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res += t[l++];\n            if (r & 1) res += t[--r];\n        }\n        return res;\n    }\n};",
        "description": "lazy_seg_tree",
        "scope": "cpp"
    },
    "levenshtein": {
        "prefix": "levenshtein",
        "body": "int editDist(string str1, string str2) {\n\tint m = str1.size(), n = str2.size();\n\tvector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\tfor (int i = 0; i <= m; i++)\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (i == 0) dp[i][j] = j;\n\t\t\telse if (j == 0) dp[i][j] = i;\n\t\t\telse if (str1[i - 1] == str2[j - 1])\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\telse\n\t\t\t\tdp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\n\t\t}\n\treturn dp[m][n];\n}",
        "description": "levenshtein",
        "scope": "cpp"
    },
    "matrix": {
        "prefix": "matrix",
        "body": "#define vi vector<int>\n#define sz(v) int((v).size())\nvector<vi> matmul(vector<vi> A, vector<vi> B) {\n    int n = sz(A), m = sz(A[0]), p = sz(B[0]);\n    assert(sz(B) == m);\n    vector<vi> C(n, vi(p, 0));\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < p; j++)\n            for (int k = 0; k < m; k++)\n                C[i][j] += A[i][k] * B[k][j];\n    return C;\n}\nvector<vi> matexp(vector<vi> A, int k) {\n    int n = A.size();\n    assert(sz(A[0]) == n);\n    vector<vi> C(n, vi(n, 0));\n    for (int i = 0; i < n; i++) C[i][i]++;\n    while (k) {\n        if (k & 1) C = matmul(C, A);\n        A = matmul(A, A); k >>= 1;\n    }\n    return C;\n}\nvoid matprint(vector<vi> A) {\n    for (int i = 0; i < A.size(); i++) {\n        for (int j = 0; j < A[i].size(); j++)\n            cout << A[i][j] << \" \";\n        cout << endl;\n    }\n}\nvector<vi> matadd(vector<vi> A, vector<vi> B) {\n    int n = sz(A), m = sz(A[0]);\n    assert(sz(B) == n); assert(sz(B[0]) == m);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            A[i][j] += B[i][j];\n    return A;\n}\nvector<vi> matsub(vector<vi> A, vector<vi> B) {\n    int n = sz(A), m = sz(A[0]);\n    assert(sz(B) == n); assert(sz(B[0]) == m);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            A[i][j] -= B[i][j];\n    return A;\n}\nvector<vi> matmults(vector<vi> A, int k) {\n    for (int i = 0; i < A.size(); i++)\n        for (int j = 0; j < A[i].size(); j++)\n            A[i][j] *= k;\n    return A;\n}",
        "description": "matrices",
        "scope": "cpp"
    },
    "matrix-arithmetic": {
        "prefix": "matrix-arithmetic",
        "body": "struct Matrix {\n    using vi = vector<int>;\n    int n, m, mod = 1e9 + 7;\n    vector<vi> M;\n    Matrix(int n1, int m1) {\n        n = n1, m = m1;\n        M.assign(n, vi(m, 0));\n    }\n    Matrix operator*(const Matrix& B) {\n        assert(B.n == m);\n        Matrix C = Matrix(n, B.m);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < B.m; j++)\n                for (int k = 0; k < m; k++)\n                    C.M[i][j] = (C.M[i][j] + 1LL * M[i][k] * B.M[k][j]) % mod;\n        return C;\n    }\n    Matrix operator*(const int& k) {\n        Matrix C = *this;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                C.M[i][j] = (C.M[i][j] * k) % mod;\n        return C;\n    }\n    Matrix operator+(const Matrix& B) {\n        assert(B.n == n && B.m == m);\n        Matrix C = Matrix(n, m);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                C.M[i][j] = (M[i][j] + B.M[i][j]) % mod;\n        return C;\n    }\n    Matrix operator-(const Matrix& B) {\n        assert(B.n == n && B.m == m);\n        Matrix C = Matrix(n, m);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                C.M[i][j] = (M[i][j] - B.M[i][j]) % mod;\n        return C;\n    }\n    Matrix exp(ll k) {\n        assert(m == n);\n        Matrix C = Matrix(n, n), A = *this;\n        for (int i = 0; i < n; i++) C.M[i][i]++;\n        while (k) {\n            if (k & 1) C = C * A;\n            A = A * A, k >>= 1;\n        }\n        return C;\n    }\n};",
        "description": "matrix-arithmetic",
        "scope": "cpp"
    },
    "modular": {
        "prefix": "modular",
        "body": "template<typename T> T gcd(T a, T b) {while (b) {T t = b; b = a % b; a = t;} return a;}\ntemplate<typename T> T lcm(T a, T b) {return (a * (b / gcd(a, b)));}\ntemplate<typename T> T add(T a, T b, T c = MOD) {T res = a + b; return (res >= c ? res - c : res);}\ntemplate<typename T> T mod_neg(T a, T b, T c = MOD) {T res; if (abs(a - b) < c)res = a - b; else res = (a - b) % c; return (res < 0 ? res + c : res);}\ntemplate<typename T> T mul(T a, T b, T c = MOD) {ll res = (ll)a * b; return (res >= c ? res % c : res);}\ntemplate<typename T> T mulmod(T a, T b, T m = MOD) {ll q = (ll)(((LD)a * (LD)b) / (LD)m); ll r = a * b - q * m; if (r > m)r %= m; if (r < 0)r += m; return r;}\ntemplate<typename T>T expo(T e, T n) {T x = 1, p = e; while (n) {if (n & 1)x = x * p; p = p * p; n >>= 1;} return x;}\ntemplate<typename T>T power(T e, T n, T m = MOD) {T x = 1, p = e; while (n) {if (n & 1)x = mul(x, p, m); p = mul(p, p, m); n >>= 1;} return x;}\ntemplate<typename T>T extended_euclid(T a, T b, T &x, T &y) {\n    T xx = 0, yy = 1; y = 0; x = 1; while (b) {\n        T q = a / b, t = b; b = a % b; a = t; \\\n        t = xx; xx = x - q * xx; x = t; t = yy; yy = y - q * yy; y = t;\n    } return a;\n}\ntemplate<typename T>T mod_inverse(T a, T n = MOD) {T x, y, z = 0; T d = extended_euclid(a, n, x, y); return (d > 1 ? -1 : mod_neg(x, z, n));}",
        "description": "mod",
        "scope": "cpp"
    },
    "modulo": {
        "prefix": "modulo",
        "body": "const int kMod = 998244353;\nstruct ModInt {\n\tlong long n;\n\tModInt(long long n = 0) : n(n % kMod) {}\n\tModInt operator+(const ModInt& oth) { return n + oth.n; }\n\tModInt operator-(const ModInt& oth) { return n - oth.n; }\n\tModInt operator*(const ModInt& oth) { return n * oth.n; }\n\tlong long get() { return n < 0 ? n + kMod : n; }\n};\nModInt lgpow(ModInt b, int e = -1) {\n\tif (b.get() == 0) return 0;\n\tModInt r; e = e % (kMod - 1);\n\tif (e < 0) e += kMod - 1;\n\tfor (r = 1; e; e >>= 1, b = b * b)\n\t\tif (e & 1) r = r * b;\n\treturn r;\n}\nvector<ModInt> fact, invfact;\nvoid factorials(int n) {\n\tfact.resize(n + 1, 1);\n\tinvfact.resize(n + 1, 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfact[i] = fact[i - 1] * i;\n\tinvfact[n] = lgpow(fact[n]);\n\tfor (int i = n - 1; i >= 1; --i)\n\t\tinvfact[i] = invfact[i + 1] * (i + 1);\n}\nModInt choose(int n, int k) {\n\treturn fact[n] * invfact[k] * invfact[n - k];\n}",
        "description": "modular-arithmetic",
        "scope": "cpp"
    },
    "ntt": {
        "prefix": "ntt",
        "body": "const int mod = 998244353, g = 3;\n// For p < 2^30 there is also (5 << 25, 3), (7 << 26, 3),\n// (479 << 21, 3) and (483 << 21, 5). Last two are > 10^9.\nstruct num {\n    int v;\n    num(ll v_ = 0) : v(int(v_ % mod)) {\n        if (v < 0) v += mod;\n    }\n    explicit operator int() const { return v; }\n    num operator+(const num& b) { return num(v + b.v); }\n    num operator-(const num& b) { return num(v + mod - b.v); }\n    num operator*(const num& b) { return num(1LL * v * b.v); }\n    num pow(long long b_ = -1) {\n        if (v == 0) return 0;\n        int b = b_ % (mod - 1);\n        if (b < 0) b += mod - 1;\n        num r = 1, a = *this;\n        do {\n            if (b & 1) r = r * a;\n            a = a * a;\n        } while (b >>= 1);\n        return r;\n    }\n};\nvector<int> rev({0, 1});\nvector<num> rt(2, num(1));\nstruct poly {\n    static void init(int n) {\n        int rts = rt.size();\n        if (n <= rts) return;\n        rev.resize(n);\n        for (int i = 0; i < n; i++)\n            rev[i] = (rev[i >> 1] | ((i & 1) * n)) >> 1;\n        rt.reserve(n);\n        for (int k = rts; k < n; k *= 2) {\n            rt.resize(2 * k);\n            num z = num(g).pow((mod - 1) / (2 * k));\n            for (int i = k / 2; i < k; i++)\n                rt[2 * i] = rt[i], rt[2 * i + 1] = rt[i] * z;\n        }\n    }\n    static void fft(vector<num>& a, int n) {\n        init(n);\n        int s = rev.size();\n        s = __builtin_ctz(s / n);\n        for (int i = 0; i < n; i++)\n            if (i < (rev[i] >> s))\n                swap(a[i], a[rev[i] >> s]);\n        for (int k = 1; k < n; k *= 2) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    num t = rt[j + k] * a[i + j + k];\n                    a[i + j + k] = a[i + j] - t;\n                    a[i + j] = a[i + j] + t;\n                }\n            }\n        }\n    }\n    static vector<num> inverse(vector<num>& a) {\n        if (a.empty()) return {};\n        vector<num> b(1);\n        b[0] = a[0].pow();\n        b.reserve(2 * a.size());\n        vector<num> fa;\n        while (b.size() < a.size()) {\n            int n = 2 * b.size();\n            b.resize(2 * n, 0);\n            if (fa.size() < 2 * n) fa.resize(2 * n);\n            fill(fa.begin(), fa.begin() + 2 * n, 0);\n            copy(a.begin(), a.begin() + min(n, (int)a.size()), fa.begin());\n            fft(b, 2 * n), fft(fa, 2 * n);\n            num d = num(2 * n).pow();\n            for (int i = 0; i < 2 * n; i++)\n                b[i] = b[i] * (num(2) - fa[i] * b[i]) * d;\n            reverse(b.begin() + 1, b.end());\n            fft(b, 2 * n);\n            b.resize(n);\n        }\n        b.resize(a.size());\n        return b;\n    }\n    static vector<num> multiply(vector<num> a, vector<num> b) {\n        int sza = a.size();\n        int szb = b.size();\n        int s = sza + szb - 1;\n        if (s <= 0) return {};\n        int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;\n        a.resize(n), b.resize(n);\n        fft(a, n), fft(b, n);\n        num d = num(n).pow();\n        for (int i = 0; i < n; i++)\n            a[i] = a[i] * b[i] * d;\n        reverse(a.begin() + 1, a.end());\n        fft(a, n);\n        a.resize(s);\n        return a;\n    }\n    vector<num> coef;\n    poly(vector<num> v = {}) { coef = v; }\n    poly& operator+=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] + b.coef[i];\n        return *this;\n    }\n    poly operator+(const poly& b) {\n        poly r = *this;\n        r += b;\n        return r;\n    }\n    poly& operator-=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) coef.resize(szb);\n        for (int i = 0; i < szb; i++)\n            coef[i] = coef[i] - b.coef[i];\n        return *this;\n    }\n    poly operator-(const poly& b) {\n        poly r = *this;\n        r -= b;\n        return r;\n    }\n    poly operator*(const poly& b) {\n        return poly(multiply(coef, b.coef));\n    }\n    poly& operator*=(const poly& b) {\n        coef = multiply(coef, b.coef);\n        return *this;\n    }\n    poly& operator*=(const num& b) {\n        for (num& x : coef) x = x * b;\n        return *this;\n    }\n    // Polynomial floor division; no leading 0's plz\n    poly& operator/=(poly b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza < szb) {\n            coef.clear();\n            return *this;\n        }\n        int s = sza - szb + 1;\n        reverse(coef.begin(), coef.end());\n        reverse(b.coef.begin(), b.coef.end());\n        coef.resize(s), b.coef.resize(s);\n        coef = multiply(coef, inverse(b.coef));\n        coef.resize(s);\n        reverse(coef.begin(), coef.end());\n        return *this;\n    }\n    poly operator/(const poly& b) {\n        poly r = *this;\n        r /= b;\n        return r;\n    }\n    poly& operator%=(const poly& b) {\n        int sza = coef.size();\n        int szb = b.coef.size();\n        if (sza >= szb) {\n            poly c = *this;\n            c /= b;\n            c *= b;\n            coef.resize(szb - 1);\n            for (int i = 0; i < sza; i++)\n                coef[i] = coef[i] - c.coef[i];\n        }\n        return *this;\n    }\n    poly operator%(const poly& b) {\n        poly r = *this;\n        r %= b;\n        return r;\n    }\n    poly deriv() {\n        if (coef.empty()) return poly();\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza - 1);\n        for (int i = 1; i < sza; i++)\n            b.coef[i - 1] = coef[i] * i;\n        return b;\n    }\n    poly integ() {\n        int sza = coef.size();\n        poly b;\n        b.coef.resize(sza + 1);\n        b.coef[1] = 1;\n        for (int i = 2; i <= sza; i++)\n            b.coef[i] = b.coef[mod % i] * (-mod / i);\n        for (int i = 1; i <= sza; i++)\n            b.coef[i] = coef[i - 1] * b.coef[i];\n        return b;\n    }\n    poly log() {  // coef[0] == 1\n        poly a = this->deriv();\n        poly b = poly(multiply(coef, inverse(a.coef)));\n        b = b.integ();\n        b.coef.resize(coef.size());\n        return b;\n    }\n    poly exp() {  // coef[0] == 0\n        poly b;\n        b.coef.assign(1, num(1));\n        if (coef.empty()) return b;\n        while (b.coef.size() < coef.size()) {\n            int sza = coef.size();\n            int szb = b.coef.size();\n            int n = min(szb * 2, sza);\n            b.coef.resize(n);\n            poly v;\n            v.coef.resize(n);\n            for (int i = 0; i < n; i++)\n                v.coef[i] = coef[i];\n            v -= b.log();\n            v.coef[0] = v.coef[0] + num(1);\n            b *= v;\n            b.coef.resize(n);\n        }\n        return b;\n    }\n    poly pow(int m) {  // m >= 0\n        poly b;\n        int sza = coef.size();\n        b.coef.resize(sza);\n        if (m == 0) {\n            b.coef[0] = 1;\n            return b;\n        }\n        int p = 0;\n        while (p < sza && coef[p].v == 0) ++p;\n        if (1LL * m * p >= sza) return b;\n        num mu = coef[p].pow(m), di = coef[p].pow();\n        poly c;\n        c.coef.resize(sza - m * p);\n        for (int i = 0; i < c.coef.size(); i++)\n            c.coef[i] = coef[i + p] * di;\n        c = c.log();\n        for (num& v : c.coef)\n            v = v * m;\n        c = c.exp();\n        for (int i = 0; i < c.coef.size(); i++)\n            b.coef[i + m * p] = c.coef[i] * mu;\n        return b;\n    }\n    vector<num> eval(const vector<num>& x) {\n        int n = x.size();\n        if (!n) return {};\n        vector<poly> up(2 * n);\n        for (int i = 0; i < n; i++) {\n            vector<num> tmp = {num(num(0) - x[i]), num(1)};\n            up[i + n] = poly(tmp);\n        }\n        for (int i = n - 1; i >= 1; i--)\n            up[i] = up[2 * i] * up[2 * i + 1];\n        vector<poly> down(2 * n);\n        down[1] = (*this) % up[1];\n        for (int i = 2; i < 2 * n; i++)\n            down[i] = down[i / 2] % up[i];\n        vector<num> y(n);\n        for (int i = 0; i < n; i++)\n            y[i] = down[i + n].coef[0];\n        return y;\n    }\n};\npoly interp(const vector<num>& x, const vector<num>& y) {\n    int n = x.size();\n    assert(n);\n    vector<poly> up(n * 2);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {num(num(0) - x[i]), num(1)};\n        up[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        up[i] = up[2 * i] * up[2 * i + 1];\n    vector<num> a = up[1].deriv().eval(x);\n    vector<poly> down(2 * n);\n    for (int i = 0; i < n; i++) {\n        vector<num> tmp = {a[i].pow() * y[i]};\n        down[i + n] = poly(tmp);\n    }\n    for (int i = n - 1; i >= 1; i--)\n        down[i] = down[i * 2] * up[i * 2 + 1] + down[i * 2 + 1] * up[i * 2];\n    return down[1];\n}",
        "description": "number_theoretic_transform",
        "scope": "cpp"
    },
    "pbds": {
        "prefix": "pbds",
        "body": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate <class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the iterator to kth largest element.(0-based)",
        "description": "pbds",
        "scope": "cpp"
    },
    "pragmas": {
        "prefix": "pragmas",
        "body": "#pragma GCC optimize(\"O3\")\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")",
        "description": "pragma",
        "scope": "cpp"
    },
    "randoms": {
        "prefix": "randoms",
        "body": "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n#define shuf(v) shuffle((v).begin(), (v).end(), rng);\n// Use mt19937_64 for 64 bit random numbers.",
        "description": "random",
        "scope": "cpp"
    },
    "readfns": {
        "prefix": "readfns",
        "body": "inline int read() {int x; cin >> x; return x;}\ninline long long readl() {long long x; cin >> x; return x;}\ninline char readc() {char x; cin >> x; return x;}\ninline string reads() {string x; cin >> x; return x;}",
        "description": "read",
        "scope": "cpp"
    },
    "seg_tree": {
        "prefix": "seg_tree",
        "body": "struct segtree {\n    vector<int> t;\n    int n;\n    segtree(int m) {n = m; t.assign(4 * n, 0);}\n    void build_aux(vector<int>& a, int v, int tl, int tr) {\n        if (tl == tr) {t[v] = a[tl]; return;}\n        int tm = (tl + tr) / 2;\n        build_aux(a, v * 2, tl, tm);\n        build_aux(a, v * 2 + 1, tm + 1, tr);\n        t[v] = t[v * 2] + t[v * 2 + 1];\n    }\n    int query_aux(int v, int tl, int tr, int l, int r) {\n        if (l > r) return 0;\n        if (l == tl && r == tr) return t[v];\n        int tm = (tl + tr) / 2;\n        return query_aux(v * 2, tl, tm, l, min(r, tm)) +\n               query_aux(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n    }\n    void update_aux(int v, int tl, int tr, int pos, int new_val) {\n        if (tl == tr) {t[v] = new_val; return;}\n        int tm = (tl + tr) / 2;\n        if (pos <= tm) update_aux(v * 2, tl, tm, pos, new_val);\n        else update_aux(v * 2 + 1, tm + 1, tr, pos, new_val);\n        t[v] = t[v * 2] + t[v * 2 + 1];\n    }\n    void build(vector<int>& a) {\n        n = a.size(); t.assign(4 * n, 0);\n        build_aux(a, 1, 0, n - 1);\n    }\n    void update(int i, int x) {\n        update_aux(1, 0, n - 1, i, x);\n    }\n    int query(int l, int r) {\n        return query_aux(1, 0, n - 1, l, r);\n    }\n};",
        "description": "seg_tree",
        "scope": "cpp"
    },
    "sieve": {
        "prefix": "sieve",
        "body": "const int N = 2e6 + 10;\nvoid sieve() {\n\tleast[0] = 0; least[1] = 1;\n\tfor (int i = 2; i < N; i++)\n\t\tleast[i] = (i % 2) ? i : 2;\n\tfor (int i = 3; i * i <= N; i += 2) {\n\t\tif (least[i] != i) continue;\n\t\tfor (int j = i * i; j < N; j += i)\n\t\t\tif (least[j] == j)\n\t\t\t\tleast[j] = i;\n\t}\n}",
        "description": "sieve",
        "scope": "cpp"
    },
    "sqrtdec": {
        "prefix": "sqrtdec",
        "body": "struct decomp {\n    vector<int> state, block, sums;\n    int n, rt;\n    decomp(int m) {\n        n = m;\n        rt = sqrtl(n) + 1;\n        block.assign(rt + 1, 0);\n        sums.assign(rt + 1, 0);\n        state.assign(n, 0);\n    }\n    void update(int i, int j) {\n        if (i > j) return;\n        if (i < 0) return update(0, j);\n        if (j >= n) return update(i, n - 1);\n        int ri = i / rt, rj = j / rt;\n        if (ri == rj) {\n            for (int it = i; it <= j; it++) {\n                state[it] = 1 - state[it];\n                int ch = 2 * state[it] - 1;\n                sums[ri] += block[ri] ? -ch : ch;\n            }\n            return;\n        }\n        for (int it = ++ri; it < rj; it++) {\n            sums[it] = rt - sums[it];\n            block[it] = 1 - block[it];\n        }\n        update(i, ri * rt - 1);\n        update(rj * rt, j);\n    }\n    int query(int i, int j) {\n        if (i > j) return 0;\n        if (i < 0) return query(0, j);\n        if (j >= n) return query(i, n - 1);\n        int ri = i / rt, rj = j / rt;\n        int ans = 0;\n        if (ri == rj) {\n            for (int it = i; it <= j; it++)\n                ans += block[ri] ? (1 - state[it]) : state[it];\n            return ans;\n        }\n        for (int it = ++ri; it < rj; it++)\n            ans += sums[it];\n        ans += query(i, ri * rt - 1);\n        ans += query(rj * rt, j);\n        return ans;\n    }\n};",
        "description": "sqrt-decomposition",
        "scope": "cpp"
    },
    "cpp": {
        "prefix": "cpp",
        "body": "// #pragma GCC optimize(\"O3\")\n// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <ratio>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\n#ifdef LOCAL\n#include \"trace.h\"\n#else\n#define trace(args...)\n#endif\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\ntypedef pair<int, int> pi;\ntypedef pair<long long, long long> pl;\ntypedef pair<long double, long double> pd;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<long double> vd;\ntypedef vector<string> vs;\ntypedef vector<pair<ll, ll>> vpl;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n        tree_order_statistics_node_update> ordered_set;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the iterator to kth largest element.(0-based)\n\n#define forn(i, a, b) for (int i = (a); i <= (b); i++)\n#define rfor(i, b, a) for (int i = (b); i >= (a); i--)\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define forv(i, v) for (auto& (i) : (v))\n#define trav(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n\n#define all(v) (v).begin(), (v).end()\n#define sz(v) (int)(v).size()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pc(c) putchar(c)\n#define gc(c) getchar(c)\n#define runtime() (int)(1000 * ((double)clock()) / CLOCKS_PER_SEC)\n#define flush() cout << flush\n#define max_queue(t) priority_queue<t>\n#define min_queue(t) priority_queue<t,vector<t>,greater<t>>\n\n#define popcnt __builtin_popcount\n#define popcntll __builtin_popcountll\n#define ctz __builtin_ctz\n#define ctzll __builtin_ctzll\n\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define ef emplace_front\n#define eb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define rsz resize\n#define ins insert\n#define endl \"\\n\"\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n#define shuf(v) shuffle((v).begin(), (v).end(), rng);\n// Use mt19937_64 for 64 bit random numbers.\n\n#define Set(n, i) n = (n) | (1LL << (i))\n#define Reset(n, i) n = (n) & ~(1LL << (i))\n#define Test(n, i) ((n) >> (i) & 1LL)\n#define par(n) (n) & 1LL\n\ninline int read() {int x; cin >> x; return x;}\ninline long long readl() {long long x; cin >> x; return x;}\ninline char readc() {char x; cin >> x; return x;}\ninline string reads() {string x; cin >> x; return x;}\n\nconst double Pi = 3.1415926535898;\ninline void solve();\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif\n    cout << fixed << setprecision(10);\n    int t = 1;\n    // cin >> t;\n    for (int i = 1; i <= t; i++) {\n        // cout << \"Case #\" << i << \": \";\n        solve();\n    }\n#ifdef LOCAL\n    cout << \"\\nTime Elapsed: \" << runtime() << \" ms\\n\";\n#endif\n    return 0;\n}\n//------------------------------------------ end -----------------------------------------------//\nconst int N = 1e9 + 7;\nconst int mod = 998244353;\ninline void solve() {\n\n}",
        "description": "start_code",
        "scope": "cpp"
    },
    "suffix_array": {
        "prefix": "suffix_array",
        "body": "struct suf_array {\n    int n, alphabet = 256;\n    string s;\n    bool store_cc;\n    vector<int> p, c, cnt, base_lcp, logs;\n    vector<vector<int>> st, cc;\n    void build_suf_array() {\n        // base case k = 0\n        // count sort\n        for (int i = 0; i < n; i++)\n            cnt[s[i]]++;\n        for (int i = 1; i < alphabet; i++)\n            cnt[i] += cnt[i - 1];\n        for (int i = 0; i < n; i++)\n            p[--cnt[s[i]]] = i;\n        // calculate equivalence classes\n        c[p[0]] = 0;\n        int classes = 1;\n        for (int i = 1; i < n; i++) {\n            if (s[p[i]] != s[p[i - 1]])\n                classes++;\n            c[p[i]] = classes - 1;\n        }\n        if (store_cc)\n            cc.push_back(c);\n        // transition k -> k + 1\n        vector<int> pn(n), cn(n);\n        for (int h = 0, dh = 1; (1 << h) < n; ++h, dh <<= 1) {\n            // back shift\n            for (int i = 0; i < n; i++) {\n                pn[i] = p[i] - dh;\n                if (pn[i] < 0) pn[i] += n;\n            }\n            // count sort\n            fill(cnt.begin(), cnt.begin() + classes, 0);\n            for (int i = 0; i < n; i++)\n                cnt[c[pn[i]]]++;\n            for (int i = 1; i < classes; i++)\n                cnt[i] += cnt[i - 1];\n            for (int i = n - 1; i >= 0; i--)\n                p[--cnt[c[pn[i]]]] = pn[i];\n            // recalculate equivalence classes\n            cn[p[0]] = 0, classes = 1;\n            pair<int, int> prv = {c[p[0]], c[(p[0] + dh) % n]};\n            for (int i = 1; i < n; i++) {\n                pair<int, int> cur = {c[p[i]], c[(p[i] + dh) % n]};\n                if (cur != prv)\n                    ++classes;\n                cn[p[i]] = classes - 1;\n                prv = cur;\n            }\n            if (store_cc)\n                cc.push_back(cn);\n            c.swap(cn);\n        }\n    }\n    void build_lcp() {\n        int k = 0;\n        // base_lcp[0] is useless\n        base_lcp.assign(n, 0);\n        for (int i = 0; i < n - 1; i++) {\n            int j = p[c[i] - 1];\n            while (i + k < n &&\n                   j + k < n &&\n                   s[i + k] == s[j + k])\n                k++;\n            base_lcp[c[i]] = k;\n            k = max(k - 1, 0);\n        }\n    }\n    void build_logs() {\n        // precalculation logs[i] = int(log2(i))\n        logs.assign(n + 1, 0);\n        for (int i = 2; i <= n; i++)\n            logs[i] = logs[i / 2] + 1;\n    }\n    void build_sparse_table() {\n        // sparse table building\n        st.assign(n, vector<int>(logs[n] + 1));\n        for (int i = 0; i < n; i++)\n            st[i][0] = base_lcp[i];\n        for (int j = 1; j <= logs[n]; j++)\n            for (int i = 0; i + (1 << j) <= n; i++)\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n    }\n    suf_array(const string& ss) {\n        s = ss + char(36);\n        n = s.size();\n        p.resize(n);\n        c.resize(n);\n        cnt.assign(max(n, alphabet), 0);\n        store_cc = false;\n        build_suf_array();\n        build_lcp();\n        // build_logs();\n        // build_sparse_table();\n    }\n    pair<int, int> repr(int i, int l) {\n        // returns pair representation of prefix \n        // of length l if i-th suffix\n        assert(store_cc);\n        int k = logs[l];\n        return make_pair(cc[k][i], cc[k][(i + l - (1 << k)) % n]);\n    }\n    int lcp(int i, int j) {\n        // lcp of i-th suffix and j-th suffix, 0-indexed\n        // i, j are original indices, not in p!\n        if (i == j) return n - i - 1;\n        int L = c[i], R = c[j];\n        if (R < L) swap(R, L);\n        int len = logs[R - L];\n        L++, R++;\n        int mn = min(st[L][len], st[R - (1 << len)][len]);\n        return mn;\n    }\n    int lower_bound(const string& t) {\n        int k = t.size();\n        int lo = 0, hi = n, mid;\n        while (lo < hi - 1) {\n            mid = lo + (hi - lo) / 2;\n            if (s.substr(p[mid], k) < t)\n                lo = mid;\n            else\n                hi = mid;\n        }\n        return hi;\n    }\n    int upper_bound(const string& t) {\n        int k = t.size();\n        int lo = 0, hi = n, mid;\n        while (lo < hi - 1) {\n            mid = lo + (hi - lo) / 2;\n            if (s.substr(p[mid], k) <= t)\n                lo = mid;\n            else\n                hi = mid;\n        }\n        return hi;\n    }\n};",
        "description": "suffix_array",
        "scope": "cpp"
    },
    "trie": {
        "prefix": "trie",
        "body": "const int K = 26;\nconst int def = -1;\nint root = 0;\nstruct Vertex {\n    int nxt[K], go[K];\n    bool leaf = false;\n    int par = def, link = def;\n    char pch = '$';\n    Vertex(int par = def, char ch = '$') : par(par), pch(ch) {\n        fill(begin(nxt), end(nxt), def);\n        fill(begin(go), end(go), def);\n    }\n};\nvector<Vertex> trie(1);\nvoid add_string(int v = root, string const& s) {\n    for (char ch : s) {\n        int c = ch - 'a';\n        if (trie[v].nxt[c] == def) {\n            trie[v].nxt[c] = trie.size();\n            trie.emplace_back(v, ch);\n        }\n        v = trie[v].nxt[c];\n    }\n    trie[v].leaf = true;\n}\nint go(int v, char ch);\nint get_link(int v) {\n    if (trie[v].link != def)\n        return trie[v].link;\n    if (v == root || trie[v].par == root)\n        trie[v].link = root;\n    else\n        trie[v].link = go(get_link(trie[v].par), trie[v].pch);\n    return trie[v].link;\n}\nint go(int v, char ch) {\n    int c = ch - 'a';\n    if (trie[v].go[c] != def)\n        return trie[v].go[c];\n    if (trie[v].nxt[c] != def)\n        trie[v].go[c] = trie[v].nxt[c];\n    else if (v == root)\n        trie[v].go[c] = root;\n    else\n        trie[v].go[c] = go(get_link(v), ch);\n    return trie[v].go[c];\n}\nvoid dfs(int v) {\n    for (int i = 0; i < K; i++) {\n        if (trie[v].nxt[i] == def) continue;\n        dfs(trie[v].nxt[i]);\n    }\n}",
        "description": "trie",
        "scope": "cpp"
    },
    "types": {
        "prefix": "types",
        "body": "typedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\ntypedef pair<int, int> pi;\ntypedef pair<long long, long long> pl;\ntypedef pair<long double, long double> pd;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<long double> vd;\ntypedef vector<string> vs;\ntypedef vector<pair<ll, ll>> vpl;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\n        tree_order_statistics_node_update> ordered_set;\n// order_of_key (val): returns the no. of values less than val\n// find_by_order (k): returns the iterator to kth largest element.(0-based)",
        "description": "typedefs",
        "scope": "cpp"
    },
    "dsu": {
        "prefix": "dsu",
        "body": "vector<int> siz, par;\nint root(int a) {\n\tif (par[a] == -1) par[a] = a;\n\tint _a = a;\n\twhile (a != par[a]) a = par[a];\n\tpar[_a] = a;\n\treturn a;\n}\nvoid add(int a, int b) {\n\ta = root(a); b = root(b);\n\tif (a == b) return;\n\tif (siz[a] < siz[b]) swap(a, b);\n\tsiz[a] += siz[b];\n\tpar[b] = a;\n}",
        "description": "unionfind",
        "scope": "cpp"
    }
}